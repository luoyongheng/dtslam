

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Solving &mdash; Ceres Solver</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Ceres Solver" href="index.html"/>
        <link rel="next" title="FAQS, Tips &amp; Tricks" href="faqs.html"/>
        <link rel="prev" title="Modeling" href="modeling.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> Ceres Solver</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building &amp; Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="building.html#getting-the-source-code">Getting the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-linux">Building on Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-mac-os-x">Building on Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-windows-with-visual-studio">Building on Windows with Visual Studio</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-android">Building on Android</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-ios">Building on iOS</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#customizing-the-build">Customizing the build</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#using-ceres-with-cmake">Using Ceres with CMake</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#hello-world">Hello World!</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#derivatives">Derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#powell-s-function">Powell&#8217;s Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#curve-fitting">Curve Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#robust-curve-fitting">Robust Curve Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#bundle-adjustment">Bundle Adjustment</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#other-examples">Other Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#costfunction"><tt class="docutils literal"><span class="pre">CostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#sizedcostfunction"><tt class="docutils literal"><span class="pre">SizedCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#autodiffcostfunction"><tt class="docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#dynamicautodiffcostfunction"><tt class="docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#numericdiffcostfunction"><tt class="docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#dynamicnumericdiffcostfunction"><tt class="docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#numericdifffunctor"><tt class="docutils literal"><span class="pre">NumericDiffFunctor</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#costfunctiontofunctor"><tt class="docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#conditionedcostfunction"><tt class="docutils literal"><span class="pre">ConditionedCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#normalprior"><tt class="docutils literal"><span class="pre">NormalPrior</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#lossfunction"><tt class="docutils literal"><span class="pre">LossFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#localparameterization"><tt class="docutils literal"><span class="pre">LocalParameterization</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#autodifflocalparameterization"><tt class="docutils literal"><span class="pre">AutoDiffLocalParameterization</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#problem"><tt class="docutils literal"><span class="pre">Problem</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#rotation-h"><tt class="docutils literal"><span class="pre">rotation.h</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Solving</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trust-region-methods">Trust Region Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#line-search-methods">Line Search Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linearsolver">LinearSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#covariance-estimation">Covariance Estimation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faqs.html">FAQS, Tips &amp; Tricks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#building">Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#modeling">Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#solving">Solving</a></li>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#setting-up-your-development-environment">Setting up your Development Environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#submitting-a-change-to-ceres-solver">Submitting a change to Ceres Solver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="version_history.html">Releases</a><ul>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id1">1.9.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id2">1.8.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id5">1.7.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id9">1.6.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id12">1.5.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id16">1.4.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id20">1.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id23">1.2.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id25">1.2.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id27">1.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id30">1.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id33">1.1.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id35">1.1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id38">1.0.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="history.html#origin-of-the-name">Origin of the name</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Ceres Solver</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          
          <div role="main">
            
  <div class="section" id="solving">
<span id="chapter-solving"></span><h1>Solving<a class="headerlink" href="#solving" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Effective use of Ceres requires some familiarity with the basic
components of a nonlinear least squares solver, so before we describe
how to configure and use the solver, we will take a brief look at how
some of the core optimization algorithms in Ceres work.</p>
<p>Let <span class="math">\(x \in \mathbb{R}^n\)</span> be an <span class="math">\(n\)</span>-dimensional vector of
variables, and
<span class="math">\(F(x) = \left[f_1(x), ... ,  f_{m}(x) \right]^{\top}\)</span> be a
<span class="math">\(m\)</span>-dimensional function of <span class="math">\(x\)</span>.  We are interested in
solving the following optimization problem <a class="footnote-reference" href="#f1" id="id1">[1]</a> .</p>
<div class="math" id="equation-nonlinsq">
<span class="eqno">(1)</span>\[\begin{split}\arg \min_x \frac{1}{2}\|F(x)\|^2\ . \\
        L \le x \le U\end{split}\]</div>
<p>Where, <span class="math">\(L\)</span> and <span class="math">\(U\)</span> are lower and upper bounds on the
parameter vector <span class="math">\(x\)</span>.</p>
<p>Since the efficient global minimization of <a href="#equation-nonlinsq">(1)</a> for
general <span class="math">\(F(x)\)</span> is an intractable problem, we will have to settle
for finding a local minimum.</p>
<p>In the following, the Jacobian <span class="math">\(J(x)\)</span> of <span class="math">\(F(x)\)</span> is an
<span class="math">\(m\times n\)</span> matrix, where <span class="math">\(J_{ij}(x) = \partial_j f_i(x)\)</span>
and the gradient vector is <span class="math">\(g(x) = \nabla \frac{1}{2}\|F(x)\|^2
= J(x)^\top F(x)\)</span>.</p>
<p>The general strategy when solving non-linear optimization problems is
to solve a sequence of approximations to the original problem
<a class="reference internal" href="bibliography.html#nocedalwright" id="id2">[NocedalWright]</a>. At each iteration, the approximation is solved to
determine a correction <span class="math">\(\Delta x\)</span> to the vector <span class="math">\(x\)</span>. For
non-linear least squares, an approximation can be constructed by using
the linearization <span class="math">\(F(x+\Delta x) \approx F(x) + J(x)\Delta x\)</span>,
which leads to the following linear least squares problem:</p>
<div class="math" id="equation-linearapprox">
<span class="eqno">(2)</span>\[\min_{\Delta x} \frac{1}{2}\|J(x)\Delta x + F(x)\|^2\]</div>
<p>Unfortunately, naively solving a sequence of these problems and
updating <span class="math">\(x \leftarrow x+ \Delta x\)</span> leads to an algorithm that
may not converge.  To get a convergent algorithm, we need to control
the size of the step <span class="math">\(\Delta x\)</span>. Depending on how the size of
the step <span class="math">\(\Delta x\)</span> is controlled, non-linear optimization
algorithms can be divided into two major categories <a class="reference internal" href="bibliography.html#nocedalwright" id="id3">[NocedalWright]</a>.</p>
<ol class="arabic simple">
<li><strong>Trust Region</strong> The trust region approach approximates the
objective function using using a model function (often a quadratic)
over a subset of the search space known as the trust region. If the
model function succeeds in minimizing the true objective function
the trust region is expanded; conversely, otherwise it is
contracted and the model optimization problem is solved again.</li>
<li><strong>Line Search</strong> The line search approach first finds a descent
direction along which the objective function will be reduced and
then computes a step size that decides how far should move along
that direction. The descent direction can be computed by various
methods, such as gradient descent, Newton&#8217;s method and Quasi-Newton
method. The step size can be determined either exactly or
inexactly.</li>
</ol>
<p>Trust region methods are in some sense dual to line search methods:
trust region methods first choose a step size (the size of the trust
region) and then a step direction while line search methods first
choose a step direction and then a step size. Ceres implements
multiple algorithms in both categories.</p>
</div>
<div class="section" id="trust-region-methods">
<span id="section-trust-region-methods"></span><h2>Trust Region Methods<a class="headerlink" href="#trust-region-methods" title="Permalink to this headline">¶</a></h2>
<p>The basic trust region algorithm looks something like this.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Given an initial point <span class="math">\(x\)</span> and a trust region radius <span class="math">\(\mu\)</span>.</p>
</li>
<li><p class="first">Solve</p>
<div class="math">
\[\begin{split}\arg \min_{\Delta x}&amp; \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 \\
\text{such that} &amp;\|D(x)\Delta x\|^2 \le \mu\\
&amp;L \le x + \Delta x \le U.\end{split}\]</div>
</li>
<li><p class="first"><span class="math">\(\rho = \frac{\displaystyle \|F(x + \Delta x)\|^2 -
\|F(x)\|^2}{\displaystyle \|J(x)\Delta x + F(x)\|^2 -
\|F(x)\|^2}\)</span></p>
</li>
<li><p class="first">if <span class="math">\(\rho &gt; \epsilon\)</span> then  <span class="math">\(x = x + \Delta x\)</span>.</p>
</li>
<li><p class="first">if <span class="math">\(\rho &gt; \eta_1\)</span> then <span class="math">\(\rho = 2  \rho\)</span></p>
</li>
<li><p class="first">else if <span class="math">\(\rho &lt; \eta_2\)</span> then <span class="math">\(\rho = 0.5 * \rho\)</span></p>
</li>
<li><p class="first">Go to 2.</p>
</li>
</ol>
</div></blockquote>
<p>Here, <span class="math">\(\mu\)</span> is the trust region radius, <span class="math">\(D(x)\)</span> is some
matrix used to define a metric on the domain of <span class="math">\(F(x)\)</span> and
<span class="math">\(\rho\)</span> measures the quality of the step <span class="math">\(\Delta x\)</span>, i.e.,
how well did the linear model predict the decrease in the value of the
non-linear objective. The idea is to increase or decrease the radius
of the trust region depending on how well the linearization predicts
the behavior of the non-linear objective, which in turn is reflected
in the value of <span class="math">\(\rho\)</span>.</p>
<p>The key computational step in a trust-region algorithm is the solution
of the constrained optimization problem</p>
<div class="math" id="equation-trp">
<span class="eqno">(3)</span>\[\begin{split}\arg \min_{\Delta x}&amp; \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 \\
\text{such that} &amp;\|D(x)\Delta x\|^2 \le \mu\\
 &amp;L \le x + \Delta x \le U.\end{split}\]</div>
<p>There are a number of different ways of solving this problem, each
giving rise to a different concrete trust-region algorithm. Currently
Ceres, implements two trust-region algorithms - Levenberg-Marquardt
and Dogleg, each of which is augmented with a line search if bounds
constraints are present <a class="reference internal" href="bibliography.html#kanzow" id="id4">[Kanzow]</a>. The user can choose between them by
setting <a class="reference internal" href="#Solver::Options::trust_region_strategy_type__TrustRegionStrategyType" title="Solver::Options::trust_region_strategy_type"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::trust_region_strategy_type</span></tt></a>.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>At the level of the non-linear solver, the block structure is
not relevant, therefore our discussion here is in terms of an
optimization problem defined over a state vector of size
<span class="math">\(n\)</span>. Similarly the presence of loss functions is also
ignored as the problem is internally converted into a pure
non-linear least squares problem.</td></tr>
</tbody>
</table>
<div class="section" id="levenberg-marquardt">
<span id="section-levenberg-marquardt"></span><h3>Levenberg-Marquardt<a class="headerlink" href="#levenberg-marquardt" title="Permalink to this headline">¶</a></h3>
<p>The Levenberg-Marquardt algorithm <a class="reference internal" href="bibliography.html#levenberg" id="id5">[Levenberg]</a> <a class="reference internal" href="bibliography.html#marquardt" id="id6">[Marquardt]</a> is the
most popular algorithm for solving non-linear least squares problems.
It was also the first trust region algorithm to be developed
<a class="reference internal" href="bibliography.html#levenberg" id="id7">[Levenberg]</a> <a class="reference internal" href="bibliography.html#marquardt" id="id8">[Marquardt]</a>. Ceres implements an exact step <a class="reference internal" href="bibliography.html#madsen" id="id9">[Madsen]</a>
and an inexact step variant of the Levenberg-Marquardt algorithm
<a class="reference internal" href="bibliography.html#wrightholt" id="id10">[WrightHolt]</a> <a class="reference internal" href="bibliography.html#nashsofer" id="id11">[NashSofer]</a>.</p>
<p>It can be shown, that the solution to <a href="#equation-trp">(3)</a> can be obtained by
solving an unconstrained optimization of the form</p>
<div class="math">
\[\begin{split}\arg\min_{\Delta x}&amp; \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 +\lambda  \|D(x)\Delta x\|^2\end{split}\]</div>
<p>Where, <span class="math">\(\lambda\)</span> is a Lagrange multiplier that is inverse
related to <span class="math">\(\mu\)</span>. In Ceres, we solve for</p>
<div class="math" id="equation-lsqr">
<span class="eqno">(4)</span>\[\begin{split}\arg\min_{\Delta x}&amp; \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 + \frac{1}{\mu} \|D(x)\Delta x\|^2\end{split}\]</div>
<p>The matrix <span class="math">\(D(x)\)</span> is a non-negative diagonal matrix, typically
the square root of the diagonal of the matrix <span class="math">\(J(x)^\top J(x)\)</span>.</p>
<p>Before going further, let us make some notational simplifications. We
will assume that the matrix <span class="math">\(\sqrt{\mu} D\)</span> has been concatenated
at the bottom of the matrix <span class="math">\(J\)</span> and similarly a vector of zeros
has been added to the bottom of the vector <span class="math">\(f\)</span> and the rest of
our discussion will be in terms of <span class="math">\(J\)</span> and <span class="math">\(f\)</span>, i.e, the
linear least squares problem.</p>
<div class="math" id="equation-simple">
<span class="eqno">(5)</span>\[\min_{\Delta x} \frac{1}{2} \|J(x)\Delta x + f(x)\|^2 .\]</div>
<p>For all but the smallest problems the solution of <a href="#equation-simple">(5)</a> in
each iteration of the Levenberg-Marquardt algorithm is the dominant
computational cost in Ceres. Ceres provides a number of different
options for solving <a href="#equation-simple">(5)</a>. There are two major classes of
methods - factorization and iterative.</p>
<p>The factorization methods are based on computing an exact solution of
<a href="#equation-lsqr">(4)</a> using a Cholesky or a QR factorization and lead to an exact
step Levenberg-Marquardt algorithm. But it is not clear if an exact
solution of <a href="#equation-lsqr">(4)</a> is necessary at each step of the LM algorithm
to solve <a href="#equation-nonlinsq">(1)</a>. In fact, we have already seen evidence
that this may not be the case, as <a href="#equation-lsqr">(4)</a> is itself a regularized
version of <a href="#equation-linearapprox">(2)</a>. Indeed, it is possible to
construct non-linear optimization algorithms in which the linearized
problem is solved approximately. These algorithms are known as inexact
Newton or truncated Newton methods <a class="reference internal" href="bibliography.html#nocedalwright" id="id12">[NocedalWright]</a>.</p>
<p>An inexact Newton method requires two ingredients. First, a cheap
method for approximately solving systems of linear
equations. Typically an iterative linear solver like the Conjugate
Gradients method is used for this
purpose <a class="reference internal" href="bibliography.html#nocedalwright" id="id13">[NocedalWright]</a>. Second, a termination rule for
the iterative solver. A typical termination rule is of the form</p>
<div class="math" id="equation-inexact">
<span class="eqno">(6)</span>\[\|H(x) \Delta x + g(x)\| \leq \eta_k \|g(x)\|.\]</div>
<p>Here, <span class="math">\(k\)</span> indicates the Levenberg-Marquardt iteration number and
<span class="math">\(0 &lt; \eta_k &lt;1\)</span> is known as the forcing sequence.  <a class="reference internal" href="bibliography.html#wrightholt" id="id14">[WrightHolt]</a>
prove that a truncated Levenberg-Marquardt algorithm that uses an
inexact Newton step based on <a href="#equation-inexact">(6)</a> converges for any
sequence <span class="math">\(\eta_k \leq \eta_0 &lt; 1\)</span> and the rate of convergence
depends on the choice of the forcing sequence <span class="math">\(\eta_k\)</span>.</p>
<p>Ceres supports both exact and inexact step solution strategies. When
the user chooses a factorization based linear solver, the exact step
Levenberg-Marquardt algorithm is used. When the user chooses an
iterative linear solver, the inexact step Levenberg-Marquardt
algorithm is used.</p>
</div>
<div class="section" id="dogleg">
<span id="section-dogleg"></span><h3>Dogleg<a class="headerlink" href="#dogleg" title="Permalink to this headline">¶</a></h3>
<p>Another strategy for solving the trust region problem <a href="#equation-trp">(3)</a> was
introduced by M. J. D. Powell. The key idea there is to compute two
vectors</p>
<div class="math">
\[\begin{split}\Delta x^{\text{Gauss-Newton}} &amp;= \arg \min_{\Delta x}\frac{1}{2} \|J(x)\Delta x + f(x)\|^2.\\
\Delta x^{\text{Cauchy}} &amp;= -\frac{\|g(x)\|^2}{\|J(x)g(x)\|^2}g(x).\end{split}\]</div>
<p>Note that the vector <span class="math">\(\Delta x^{\text{Gauss-Newton}}\)</span> is the
solution to <a href="#equation-linearapprox">(2)</a> and <span class="math">\(\Delta
x^{\text{Cauchy}}\)</span> is the vector that minimizes the linear
approximation if we restrict ourselves to moving along the direction
of the gradient. Dogleg methods finds a vector <span class="math">\(\Delta x\)</span>
defined by <span class="math">\(\Delta x^{\text{Gauss-Newton}}\)</span> and <span class="math">\(\Delta
x^{\text{Cauchy}}\)</span> that solves the trust region problem. Ceres
supports two variants that can be chose by setting
<a class="reference internal" href="#Solver::Options::dogleg_type__DoglegType" title="Solver::Options::dogleg_type"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::dogleg_type</span></tt></a>.</p>
<p><tt class="docutils literal"><span class="pre">TRADITIONAL_DOGLEG</span></tt> as described by Powell, constructs two line
segments using the Gauss-Newton and Cauchy vectors and finds the point
farthest along this line shaped like a dogleg (hence the name) that is
contained in the trust-region. For more details on the exact reasoning
and computations, please see Madsen et al <a class="reference internal" href="bibliography.html#madsen" id="id15">[Madsen]</a>.</p>
<p><tt class="docutils literal"><span class="pre">SUBSPACE_DOGLEG</span></tt> is a more sophisticated method that considers the
entire two dimensional subspace spanned by these two vectors and finds
the point that minimizes the trust region problem in this subspace
<a class="reference internal" href="bibliography.html#byrdschnabel" id="id16">[ByrdSchnabel]</a>.</p>
<p>The key advantage of the Dogleg over Levenberg Marquardt is that if
the step computation for a particular choice of <span class="math">\(\mu\)</span> does not
result in sufficient decrease in the value of the objective function,
Levenberg-Marquardt solves the linear approximation from scratch with
a smaller value of <span class="math">\(\mu\)</span>. Dogleg on the other hand, only needs
to compute the interpolation between the Gauss-Newton and the Cauchy
vectors, as neither of them depend on the value of <span class="math">\(\mu\)</span>.</p>
<p>The Dogleg method can only be used with the exact factorization based
linear solvers.</p>
</div>
<div class="section" id="inner-iterations">
<span id="section-inner-iterations"></span><h3>Inner Iterations<a class="headerlink" href="#inner-iterations" title="Permalink to this headline">¶</a></h3>
<p>Some non-linear least squares problems have additional structure in
the way the parameter blocks interact that it is beneficial to modify
the way the trust region step is computed. e.g., consider the
following regression problem</p>
<div class="math">
\[y = a_1 e^{b_1 x} + a_2 e^{b_3 x^2 + c_1}\]</div>
<p>Given a set of pairs <span class="math">\(\{(x_i, y_i)\}\)</span>, the user wishes to estimate
<span class="math">\(a_1, a_2, b_1, b_2\)</span>, and <span class="math">\(c_1\)</span>.</p>
<p>Notice that the expression on the left is linear in <span class="math">\(a_1\)</span> and
<span class="math">\(a_2\)</span>, and given any value for <span class="math">\(b_1, b_2\)</span> and <span class="math">\(c_1\)</span>,
it is possible to use linear regression to estimate the optimal values
of <span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span>. It&#8217;s possible to analytically
eliminate the variables <span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span> from the problem
entirely. Problems like these are known as separable least squares
problem and the most famous algorithm for solving them is the Variable
Projection algorithm invented by Golub &amp; Pereyra <a class="reference internal" href="bibliography.html#golubpereyra" id="id17">[GolubPereyra]</a>.</p>
<p>Similar structure can be found in the matrix factorization with
missing data problem. There the corresponding algorithm is known as
Wiberg&#8217;s algorithm <a class="reference internal" href="bibliography.html#wiberg" id="id18">[Wiberg]</a>.</p>
<p>Ruhe &amp; Wedin present an analysis of various algorithms for solving
separable non-linear least squares problems and refer to <em>Variable
Projection</em> as Algorithm I in their paper <a class="reference internal" href="bibliography.html#ruhewedin" id="id19">[RuheWedin]</a>.</p>
<p>Implementing Variable Projection is tedious and expensive. Ruhe &amp;
Wedin present a simpler algorithm with comparable convergence
properties, which they call Algorithm II.  Algorithm II performs an
additional optimization step to estimate <span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span>
exactly after computing a successful Newton step.</p>
<p>This idea can be generalized to cases where the residual is not
linear in <span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span>, i.e.,</p>
<div class="math">
\[y = f_1(a_1, e^{b_1 x}) + f_2(a_2, e^{b_3 x^2 + c_1})\]</div>
<p>In this case, we solve for the trust region step for the full problem,
and then use it as the starting point to further optimize just <cite>a_1</cite>
and <cite>a_2</cite>. For the linear case, this amounts to doing a single linear
least squares solve. For non-linear problems, any method for solving
the <span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span> optimization problems will do. The
only constraint on <span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span> (if they are two
different parameter block) is that they do not co-occur in a residual
block.</p>
<p>This idea can be further generalized, by not just optimizing
<span class="math">\((a_1, a_2)\)</span>, but decomposing the graph corresponding to the
Hessian matrix&#8217;s sparsity structure into a collection of
non-overlapping independent sets and optimizing each of them.</p>
<p>Setting <a class="reference internal" href="#Solver::Options::use_inner_iterations__b" title="Solver::Options::use_inner_iterations"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::use_inner_iterations</span></tt></a> to <tt class="docutils literal"><span class="pre">true</span></tt>
enables the use of this non-linear generalization of Ruhe &amp; Wedin&#8217;s
Algorithm II.  This version of Ceres has a higher iteration
complexity, but also displays better convergence behavior per
iteration.</p>
<p>Setting <a class="reference internal" href="#Solver::Options::num_threads__i" title="Solver::Options::num_threads"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::num_threads</span></tt></a> to the maximum number
possible is highly recommended.</p>
</div>
<div class="section" id="non-monotonic-steps">
<span id="section-non-monotonic-steps"></span><h3>Non-monotonic Steps<a class="headerlink" href="#non-monotonic-steps" title="Permalink to this headline">¶</a></h3>
<p>Note that the basic trust-region algorithm described in
<a class="reference internal" href="#section-trust-region-methods"><em>Trust Region Methods</em></a> is a descent algorithm in that it
only accepts a point if it strictly reduces the value of the objective
function.</p>
<p>Relaxing this requirement allows the algorithm to be more efficient in
the long term at the cost of some local increase in the value of the
objective function.</p>
<p>This is because allowing for non-decreasing objective function values
in a principled manner allows the algorithm to <em>jump over boulders</em> as
the method is not restricted to move into narrow valleys while
preserving its convergence properties.</p>
<p>Setting <a class="reference internal" href="#Solver::Options::use_nonmonotonic_steps__b" title="Solver::Options::use_nonmonotonic_steps"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::use_nonmonotonic_steps</span></tt></a> to <tt class="docutils literal"><span class="pre">true</span></tt>
enables the non-monotonic trust region algorithm as described by Conn,
Gould &amp; Toint in <a class="reference internal" href="bibliography.html#conn" id="id20">[Conn]</a>.</p>
<p>Even though the value of the objective function may be larger
than the minimum value encountered over the course of the
optimization, the final parameters returned to the user are the
ones corresponding to the minimum cost over all iterations.</p>
<p>The option to take non-monotonic steps is available for all trust
region strategies.</p>
</div>
</div>
<div class="section" id="line-search-methods">
<span id="section-line-search-methods"></span><h2>Line Search Methods<a class="headerlink" href="#line-search-methods" title="Permalink to this headline">¶</a></h2>
<p>The line search method in Ceres Solver cannot handle bounds
constraints right now, so it can only be used for solving
unconstrained problems.</p>
<p>Line search algorithms</p>
<blockquote>
<div><ol class="arabic simple">
<li>Given an initial point <span class="math">\(x\)</span></li>
<li><span class="math">\(\Delta x = -H^{-1}(x) g(x)\)</span></li>
<li><span class="math">\(\arg \min_\mu \frac{1}{2} \| F(x + \mu \Delta x) \|^2\)</span></li>
<li><span class="math">\(x = x + \mu \Delta x\)</span></li>
<li>Goto 2.</li>
</ol>
</div></blockquote>
<p>Here <span class="math">\(H(x)\)</span> is some approximation to the Hessian of the
objective function, and <span class="math">\(g(x)\)</span> is the gradient at
<span class="math">\(x\)</span>. Depending on the choice of <span class="math">\(H(x)\)</span> we get a variety of
different search directions <span class="math">\(\Delta x\)</span>.</p>
<p>Step 4, which is a one dimensional optimization or <cite>Line Search</cite> along
<span class="math">\(\Delta x\)</span> is what gives this class of methods its name.</p>
<p>Different line search algorithms differ in their choice of the search
direction <span class="math">\(\Delta x\)</span> and the method used for one dimensional
optimization along <span class="math">\(\Delta x\)</span>. The choice of <span class="math">\(H(x)\)</span> is the
primary source of computational complexity in these
methods. Currently, Ceres Solver supports three choices of search
directions, all aimed at large scale problems.</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">STEEPEST_DESCENT</span></tt> This corresponds to choosing <span class="math">\(H(x)\)</span> to
be the identity matrix. This is not a good search direction for
anything but the simplest of the problems. It is only included here
for completeness.</li>
<li><tt class="docutils literal"><span class="pre">NONLINEAR_CONJUGATE_GRADIENT</span></tt> A generalization of the Conjugate
Gradient method to non-linear functions. The generalization can be
performed in a number of different ways, resulting in a variety of
search directions. Ceres Solver currently supports
<tt class="docutils literal"><span class="pre">FLETCHER_REEVES</span></tt>, <tt class="docutils literal"><span class="pre">POLAK_RIBIRERE</span></tt> and <tt class="docutils literal"><span class="pre">HESTENES_STIEFEL</span></tt>
directions.</li>
<li><tt class="docutils literal"><span class="pre">BFGS</span></tt> A generalization of the Secant method to multiple
dimensions in which a full, dense approximation to the inverse
Hessian is maintained and used to compute a quasi-Newton step
<a class="reference internal" href="bibliography.html#nocedalwright" id="id21">[NocedalWright]</a>.  BFGS is currently the best known general
quasi-Newton algorithm.</li>
<li><tt class="docutils literal"><span class="pre">LBFGS</span></tt> A limited memory approximation to the full <tt class="docutils literal"><span class="pre">BFGS</span></tt>
method in which the last <cite>M</cite> iterations are used to approximate the
inverse Hessian used to compute a quasi-Newton step <a class="reference internal" href="bibliography.html#nocedal" id="id22">[Nocedal]</a>,
<a class="reference internal" href="bibliography.html#byrdnocedal" id="id23">[ByrdNocedal]</a>.</li>
</ol>
<p>Currently Ceres Solver supports both a backtracking and interpolation
based Armijo line search algorithm, and a sectioning / zoom
interpolation (strong) Wolfe condition line search algorithm.
However, note that in order for the assumptions underlying the
<tt class="docutils literal"><span class="pre">BFGS</span></tt> and <tt class="docutils literal"><span class="pre">LBFGS</span></tt> methods to be guaranteed to be satisfied the
Wolfe line search algorithm should be used.</p>
</div>
<div class="section" id="linearsolver">
<span id="section-linear-solver"></span><h2>LinearSolver<a class="headerlink" href="#linearsolver" title="Permalink to this headline">¶</a></h2>
<p>Recall that in both of the trust-region methods described above, the
key computational cost is the solution of a linear least squares
problem of the form</p>
<div class="math" id="equation-simple2">
<span class="eqno">(7)</span>\[\min_{\Delta x} \frac{1}{2} \|J(x)\Delta x + f(x)\|^2 .\]</div>
<p>Let <span class="math">\(H(x)= J(x)^\top J(x)\)</span> and <span class="math">\(g(x) = -J(x)^\top
f(x)\)</span>. For notational convenience let us also drop the dependence on
<span class="math">\(x\)</span>. Then it is easy to see that solving <a href="#equation-simple2">(7)</a> is
equivalent to solving the <em>normal equations</em>.</p>
<div class="math" id="equation-normal">
<span class="eqno">(8)</span>\[H \Delta x = g\]</div>
<p>Ceres provides a number of different options for solving <a href="#equation-normal">(8)</a>.</p>
<div class="section" id="dense-qr">
<span id="section-qr"></span><h3><tt class="docutils literal"><span class="pre">DENSE_QR</span></tt><a class="headerlink" href="#dense-qr" title="Permalink to this headline">¶</a></h3>
<p>For small problems (a couple of hundred parameters and a few thousand
residuals) with relatively dense Jacobians, <tt class="docutils literal"><span class="pre">DENSE_QR</span></tt> is the method
of choice <a class="reference internal" href="bibliography.html#bjorck" id="id24">[Bjorck]</a>. Let <span class="math">\(J = QR\)</span> be the QR-decomposition of
<span class="math">\(J\)</span>, where <span class="math">\(Q\)</span> is an orthonormal matrix and <span class="math">\(R\)</span> is
an upper triangular matrix <a class="reference internal" href="bibliography.html#trefethenbau" id="id25">[TrefethenBau]</a>. Then it can be shown that
the solution to <a href="#equation-normal">(8)</a> is given by</p>
<div class="math">
\[\Delta x^* = -R^{-1}Q^\top f\]</div>
<p>Ceres uses <tt class="docutils literal"><span class="pre">Eigen</span></tt> &#8216;s dense QR factorization routines.</p>
</div>
<div class="section" id="dense-normal-cholesky-sparse-normal-cholesky">
<span id="section-cholesky"></span><h3><tt class="docutils literal"><span class="pre">DENSE_NORMAL_CHOLESKY</span></tt> &amp; <tt class="docutils literal"><span class="pre">SPARSE_NORMAL_CHOLESKY</span></tt><a class="headerlink" href="#dense-normal-cholesky-sparse-normal-cholesky" title="Permalink to this headline">¶</a></h3>
<p>Large non-linear least square problems are usually sparse. In such
cases, using a dense QR factorization is inefficient. Let <span class="math">\(H =
R^\top R\)</span> be the Cholesky factorization of the normal equations, where
<span class="math">\(R\)</span> is an upper triangular matrix, then the solution to
<a href="#equation-normal">(8)</a> is given by</p>
<div class="math">
\[\Delta x^* = R^{-1} R^{-\top} g.\]</div>
<p>The observant reader will note that the <span class="math">\(R\)</span> in the Cholesky
factorization of <span class="math">\(H\)</span> is the same upper triangular matrix
<span class="math">\(R\)</span> in the QR factorization of <span class="math">\(J\)</span>. Since <span class="math">\(Q\)</span> is an
orthonormal matrix, <span class="math">\(J=QR\)</span> implies that <span class="math">\(J^\top J = R^\top
Q^\top Q R = R^\top R\)</span>. There are two variants of Cholesky
factorization &#8211; sparse and dense.</p>
<p><tt class="docutils literal"><span class="pre">DENSE_NORMAL_CHOLESKY</span></tt>  as the name implies performs a dense
Cholesky factorization of the normal equations. Ceres uses
<tt class="docutils literal"><span class="pre">Eigen</span></tt> &#8216;s dense LDLT factorization routines.</p>
<p><tt class="docutils literal"><span class="pre">SPARSE_NORMAL_CHOLESKY</span></tt>, as the name implies performs a sparse
Cholesky factorization of the normal equations. This leads to
substantial savings in time and memory for large sparse
problems. Ceres uses the sparse Cholesky factorization routines in
Professor Tim Davis&#8217; <tt class="docutils literal"><span class="pre">SuiteSparse</span></tt> or <tt class="docutils literal"><span class="pre">CXSparse</span></tt> packages <a class="reference internal" href="bibliography.html#chen" id="id26">[Chen]</a>.</p>
</div>
<div class="section" id="dense-schur-sparse-schur">
<span id="section-schur"></span><h3><tt class="docutils literal"><span class="pre">DENSE_SCHUR</span></tt> &amp; <tt class="docutils literal"><span class="pre">SPARSE_SCHUR</span></tt><a class="headerlink" href="#dense-schur-sparse-schur" title="Permalink to this headline">¶</a></h3>
<p>While it is possible to use <tt class="docutils literal"><span class="pre">SPARSE_NORMAL_CHOLESKY</span></tt> to solve bundle
adjustment problems, bundle adjustment problem have a special
structure, and a more efficient scheme for solving <a href="#equation-normal">(8)</a>
can be constructed.</p>
<p>Suppose that the SfM problem consists of <span class="math">\(p\)</span> cameras and
<span class="math">\(q\)</span> points and the variable vector <span class="math">\(x\)</span> has the block
structure <span class="math">\(x = [y_{1}, ... ,y_{p},z_{1}, ... ,z_{q}]\)</span>. Where,
<span class="math">\(y\)</span> and <span class="math">\(z\)</span> correspond to camera and point parameters,
respectively.  Further, let the camera blocks be of size <span class="math">\(c\)</span> and
the point blocks be of size <span class="math">\(s\)</span> (for most problems <span class="math">\(c\)</span> =
<span class="math">\(6\)</span>&#8211;<cite>9</cite> and <span class="math">\(s = 3\)</span>). Ceres does not impose any constancy
requirement on these block sizes, but choosing them to be constant
simplifies the exposition.</p>
<p>A key characteristic of the bundle adjustment problem is that there is
no term <span class="math">\(f_{i}\)</span> that includes two or more point blocks.  This in
turn implies that the matrix <span class="math">\(H\)</span> is of the form</p>
<div class="math" id="equation-hblock">
<span class="eqno">(9)</span>\[\begin{split}H = \left[ \begin{matrix} B &amp; E\\ E^\top &amp; C \end{matrix} \right]\ ,\end{split}\]</div>
<p>where, <span class="math">\(B \in \mathbb{R}^{pc\times pc}\)</span> is a block sparse matrix
with <span class="math">\(p\)</span> blocks of size <span class="math">\(c\times c\)</span> and <span class="math">\(C \in
\mathbb{R}^{qs\times qs}\)</span> is a block diagonal matrix with <span class="math">\(q\)</span> blocks
of size <span class="math">\(s\times s\)</span>. <span class="math">\(E \in \mathbb{R}^{pc\times qs}\)</span> is a
general block sparse matrix, with a block of size <span class="math">\(c\times s\)</span>
for each observation. Let us now block partition <span class="math">\(\Delta x =
[\Delta y,\Delta z]\)</span> and <span class="math">\(g=[v,w]\)</span> to restate <a href="#equation-normal">(8)</a>
as the block structured linear system</p>
<div class="math" id="equation-linear2">
<span class="eqno">(10)</span>\[\begin{split}\left[ \begin{matrix} B &amp; E\\ E^\top &amp; C \end{matrix}
             \right]\left[ \begin{matrix} \Delta y \\ \Delta z
                 \end{matrix} \right] = \left[ \begin{matrix} v\\ w
                 \end{matrix} \right]\ ,\end{split}\]</div>
<p>and apply Gaussian elimination to it. As we noted above, <span class="math">\(C\)</span> is
a block diagonal matrix, with small diagonal blocks of size
<span class="math">\(s\times s\)</span>.  Thus, calculating the inverse of <span class="math">\(C\)</span> by
inverting each of these blocks is cheap. This allows us to eliminate
<span class="math">\(\Delta z\)</span> by observing that <span class="math">\(\Delta z = C^{-1}(w - E^\top
\Delta y)\)</span>, giving us</p>
<div class="math" id="equation-schur">
<span class="eqno">(11)</span>\[\left[B - EC^{-1}E^\top\right] \Delta y = v - EC^{-1}w\ .\]</div>
<p>The matrix</p>
<div class="math">
\[S = B - EC^{-1}E^\top\]</div>
<p>is the Schur complement of <span class="math">\(C\)</span> in <span class="math">\(H\)</span>. It is also known as
the <em>reduced camera matrix</em>, because the only variables
participating in <a href="#equation-schur">(11)</a> are the ones corresponding to the
cameras. <span class="math">\(S \in \mathbb{R}^{pc\times pc}\)</span> is a block structured
symmetric positive definite matrix, with blocks of size <span class="math">\(c\times
c\)</span>. The block <span class="math">\(S_{ij}\)</span> corresponding to the pair of images
<span class="math">\(i\)</span> and <span class="math">\(j\)</span> is non-zero if and only if the two images
observe at least one common point.</p>
<p>Now, eq-linear2 can be solved by first forming <span class="math">\(S\)</span>, solving for
<span class="math">\(\Delta y\)</span>, and then back-substituting <span class="math">\(\Delta y\)</span> to
obtain the value of <span class="math">\(\Delta z\)</span>.  Thus, the solution of what was
an <span class="math">\(n\times n\)</span>, <span class="math">\(n=pc+qs\)</span> linear system is reduced to the
inversion of the block diagonal matrix <span class="math">\(C\)</span>, a few matrix-matrix
and matrix-vector multiplies, and the solution of block sparse
<span class="math">\(pc\times pc\)</span> linear system <a href="#equation-schur">(11)</a>.  For almost all
problems, the number of cameras is much smaller than the number of
points, <span class="math">\(p \ll q\)</span>, thus solving <a href="#equation-schur">(11)</a> is
significantly cheaper than solving <a href="#equation-linear2">(10)</a>. This is the
<em>Schur complement trick</em> <a class="reference internal" href="bibliography.html#brown" id="id27">[Brown]</a>.</p>
<p>This still leaves open the question of solving <a href="#equation-schur">(11)</a>. The
method of choice for solving symmetric positive definite systems
exactly is via the Cholesky factorization <a class="reference internal" href="bibliography.html#trefethenbau" id="id28">[TrefethenBau]</a> and
depending upon the structure of the matrix, there are, in general, two
options. The first is direct factorization, where we store and factor
<span class="math">\(S\)</span> as a dense matrix <a class="reference internal" href="bibliography.html#trefethenbau" id="id29">[TrefethenBau]</a>. This method has
<span class="math">\(O(p^2)\)</span> space complexity and <span class="math">\(O(p^3)\)</span> time complexity and
is only practical for problems with up to a few hundred cameras. Ceres
implements this strategy as the <tt class="docutils literal"><span class="pre">DENSE_SCHUR</span></tt> solver.</p>
<p>But, <span class="math">\(S\)</span> is typically a fairly sparse matrix, as most images
only see a small fraction of the scene. This leads us to the second
option: Sparse Direct Methods. These methods store <span class="math">\(S\)</span> as a
sparse matrix, use row and column re-ordering algorithms to maximize
the sparsity of the Cholesky decomposition, and focus their compute
effort on the non-zero part of the factorization <a class="reference internal" href="bibliography.html#chen" id="id30">[Chen]</a>. Sparse
direct methods, depending on the exact sparsity structure of the Schur
complement, allow bundle adjustment algorithms to significantly scale
up over those based on dense factorization. Ceres implements this
strategy as the <tt class="docutils literal"><span class="pre">SPARSE_SCHUR</span></tt> solver.</p>
</div>
<div class="section" id="cgnr">
<span id="section-cgnr"></span><h3><tt class="docutils literal"><span class="pre">CGNR</span></tt><a class="headerlink" href="#cgnr" title="Permalink to this headline">¶</a></h3>
<p>For general sparse problems, if the problem is too large for
<tt class="docutils literal"><span class="pre">CHOLMOD</span></tt> or a sparse linear algebra library is not linked into
Ceres, another option is the <tt class="docutils literal"><span class="pre">CGNR</span></tt> solver. This solver uses the
Conjugate Gradients solver on the <em>normal equations</em>, but without
forming the normal equations explicitly. It exploits the relation</p>
<div class="math">
\[H x = J^\top J x = J^\top(J x)\]</div>
<p>When the user chooses <tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt> as the linear solver, Ceres
automatically switches from the exact step algorithm to an inexact
step algorithm.</p>
</div>
<div class="section" id="iterative-schur">
<span id="section-iterative-schur"></span><h3><tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt><a class="headerlink" href="#iterative-schur" title="Permalink to this headline">¶</a></h3>
<p>Another option for bundle adjustment problems is to apply PCG to the
reduced camera matrix <span class="math">\(S\)</span> instead of <span class="math">\(H\)</span>. One reason to do
this is that <span class="math">\(S\)</span> is a much smaller matrix than <span class="math">\(H\)</span>, but
more importantly, it can be shown that <span class="math">\(\kappa(S)\leq
\kappa(H)\)</span>.  Cseres implements PCG on <span class="math">\(S\)</span> as the
<tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt> solver. When the user chooses <tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt>
as the linear solver, Ceres automatically switches from the exact step
algorithm to an inexact step algorithm.</p>
<p>The cost of forming and storing the Schur complement <span class="math">\(S\)</span> can be
prohibitive for large problems. Indeed, for an inexact Newton solver
that computes <span class="math">\(S\)</span> and runs PCG on it, almost all of its time is
spent in constructing <span class="math">\(S\)</span>; the time spent inside the PCG
algorithm is negligible in comparison. Because PCG only needs access
to <span class="math">\(S\)</span> via its product with a vector, one way to evaluate
<span class="math">\(Sx\)</span> is to observe that</p>
<div class="math">
\[\begin{split}x_1 &amp;= E^\top x\end{split}\]</div>
<div class="math">
\[\begin{split}x_2 &amp;= C^{-1} x_1\end{split}\]</div>
<div class="math">
\[\begin{split}x_3 &amp;= Ex_2\\\end{split}\]</div>
<div class="math">
\[\begin{split}x_4 &amp;= Bx\\\end{split}\]</div>
<div class="math" id="equation-schurtrick1">
<span class="eqno">(12)</span>\[\begin{split}Sx &amp;= x_4 - x_3\end{split}\]</div>
<p>Thus, we can run PCG on <span class="math">\(S\)</span> with the same computational effort
per iteration as PCG on <span class="math">\(H\)</span>, while reaping the benefits of a
more powerful preconditioner. In fact, we do not even need to compute
<span class="math">\(H\)</span>, <a href="#equation-schurtrick1">(12)</a> can be implemented using just the columns
of <span class="math">\(J\)</span>.</p>
<p>Equation <a href="#equation-schurtrick1">(12)</a> is closely related to <em>Domain
Decomposition methods</em> for solving large linear systems that arise in
structural engineering and partial differential equations. In the
language of Domain Decomposition, each point in a bundle adjustment
problem is a domain, and the cameras form the interface between these
domains. The iterative solution of the Schur complement then falls
within the sub-category of techniques known as Iterative
Sub-structuring <a class="reference internal" href="bibliography.html#saad" id="id31">[Saad]</a> <a class="reference internal" href="bibliography.html#mathew" id="id32">[Mathew]</a>.</p>
</div>
<div class="section" id="preconditioner">
<span id="section-preconditioner"></span><h3>Preconditioner<a class="headerlink" href="#preconditioner" title="Permalink to this headline">¶</a></h3>
<p>The convergence rate of Conjugate Gradients for
solving <a href="#equation-normal">(8)</a> depends on the distribution of eigenvalues
of <span class="math">\(H\)</span> <a class="reference internal" href="bibliography.html#saad" id="id33">[Saad]</a>. A useful upper bound is
<span class="math">\(\sqrt{\kappa(H)}\)</span>, where, <span class="math">\(\kappa(H)\)</span> is the condition
number of the matrix <span class="math">\(H\)</span>. For most bundle adjustment problems,
<span class="math">\(\kappa(H)\)</span> is high and a direct application of Conjugate
Gradients to <a href="#equation-normal">(8)</a> results in extremely poor performance.</p>
<p>The solution to this problem is to replace <a href="#equation-normal">(8)</a> with a
<em>preconditioned</em> system.  Given a linear system, <span class="math">\(Ax =b\)</span> and a
preconditioner <span class="math">\(M\)</span> the preconditioned system is given by
<span class="math">\(M^{-1}Ax = M^{-1}b\)</span>. The resulting algorithm is known as
Preconditioned Conjugate Gradients algorithm (PCG) and its worst case
complexity now depends on the condition number of the <em>preconditioned</em>
matrix <span class="math">\(\kappa(M^{-1}A)\)</span>.</p>
<p>The computational cost of using a preconditioner <span class="math">\(M\)</span> is the cost
of computing <span class="math">\(M\)</span> and evaluating the product <span class="math">\(M^{-1}y\)</span> for
arbitrary vectors <span class="math">\(y\)</span>. Thus, there are two competing factors to
consider: How much of <span class="math">\(H\)</span>&#8216;s structure is captured by <span class="math">\(M\)</span>
so that the condition number <span class="math">\(\kappa(HM^{-1})\)</span> is low, and the
computational cost of constructing and using <span class="math">\(M\)</span>.  The ideal
preconditioner would be one for which <span class="math">\(\kappa(M^{-1}A)
=1\)</span>. <span class="math">\(M=A\)</span> achieves this, but it is not a practical choice, as
applying this preconditioner would require solving a linear system
equivalent to the unpreconditioned problem.  It is usually the case
that the more information <span class="math">\(M\)</span> has about <span class="math">\(H\)</span>, the more
expensive it is use. For example, Incomplete Cholesky factorization
based preconditioners have much better convergence behavior than the
Jacobi preconditioner, but are also much more expensive.</p>
<p>The simplest of all preconditioners is the diagonal or Jacobi
preconditioner, i.e., <span class="math">\(M=\operatorname{diag}(A)\)</span>, which for
block structured matrices like <span class="math">\(H\)</span> can be generalized to the
block Jacobi preconditioner.</p>
<p>For <tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt> there are two obvious choices for block
diagonal preconditioners for <span class="math">\(S\)</span>. The block diagonal of the
matrix <span class="math">\(B\)</span> <a class="reference internal" href="bibliography.html#mandel" id="id34">[Mandel]</a> and the block diagonal <span class="math">\(S\)</span>, i.e, the
block Jacobi preconditioner for <span class="math">\(S\)</span>. Ceres&#8217;s implements both of
these preconditioners and refers to them as <tt class="docutils literal"><span class="pre">JACOBI</span></tt> and
<tt class="docutils literal"><span class="pre">SCHUR_JACOBI</span></tt> respectively.</p>
<p>For bundle adjustment problems arising in reconstruction from
community photo collections, more effective preconditioners can be
constructed by analyzing and exploiting the camera-point visibility
structure of the scene [KushalAgarwal]. Ceres implements the two
visibility based preconditioners described by Kushal &amp; Agarwal as
<tt class="docutils literal"><span class="pre">CLUSTER_JACOBI</span></tt> and <tt class="docutils literal"><span class="pre">CLUSTER_TRIDIAGONAL</span></tt>. These are fairly new
preconditioners and Ceres&#8217; implementation of them is in its early
stages and is not as mature as the other preconditioners described
above.</p>
</div>
<div class="section" id="ordering">
<span id="section-ordering"></span><h3>Ordering<a class="headerlink" href="#ordering" title="Permalink to this headline">¶</a></h3>
<p>The order in which variables are eliminated in a linear solver can
have a significant of impact on the efficiency and accuracy of the
method. For example when doing sparse Cholesky factorization, there
are matrices for which a good ordering will give a Cholesky factor
with <span class="math">\(O(n)\)</span> storage, where as a bad ordering will result in an
completely dense factor.</p>
<p>Ceres allows the user to provide varying amounts of hints to the
solver about the variable elimination ordering to use. This can range
from no hints, where the solver is free to decide the best ordering
based on the user&#8217;s choices like the linear solver being used, to an
exact order in which the variables should be eliminated, and a variety
of possibilities in between.</p>
<p>Instances of the <a class="reference internal" href="#ParameterBlockOrdering" title="ParameterBlockOrdering"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ParameterBlockOrdering</span></tt></a> class are used to
communicate this information to Ceres.</p>
<p>Formally an ordering is an ordered partitioning of the parameter
blocks. Each parameter block belongs to exactly one group, and each
group has a unique integer associated with it, that determines its
order in the set of groups. We call these groups <em>Elimination Groups</em></p>
<p>Given such an ordering, Ceres ensures that the parameter blocks in the
lowest numbered elimination group are eliminated first, and then the
parameter blocks in the next lowest numbered elimination group and so
on. Within each elimination group, Ceres is free to order the
parameter blocks as it chooses. e.g. Consider the linear system</p>
<div class="math">
\[\begin{split}x + y &amp;= 3\\
2x + 3y &amp;= 7\end{split}\]</div>
<p>There are two ways in which it can be solved. First eliminating
<span class="math">\(x\)</span> from the two equations, solving for y and then back
substituting for <span class="math">\(x\)</span>, or first eliminating <span class="math">\(y\)</span>, solving
for <span class="math">\(x\)</span> and back substituting for <span class="math">\(y\)</span>. The user can
construct three orderings here.</p>
<ol class="arabic simple">
<li><span class="math">\(\{0: x\}, \{1: y\}\)</span> : Eliminate <span class="math">\(x\)</span> first.</li>
<li><span class="math">\(\{0: y\}, \{1: x\}\)</span> : Eliminate <span class="math">\(y\)</span> first.</li>
<li><span class="math">\(\{0: x, y\}\)</span>        : Solver gets to decide the elimination order.</li>
</ol>
<p>Thus, to have Ceres determine the ordering automatically using
heuristics, put all the variables in the same elimination group. The
identity of the group does not matter. This is the same as not
specifying an ordering at all. To control the ordering for every
variable, create an elimination group per variable, ordering them in
the desired order.</p>
<p>If the user is using one of the Schur solvers (<tt class="docutils literal"><span class="pre">DENSE_SCHUR</span></tt>,
<tt class="docutils literal"><span class="pre">SPARSE_SCHUR</span></tt>, <tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt>) and chooses to specify an
ordering, it must have one important property. The lowest numbered
elimination group must form an independent set in the graph
corresponding to the Hessian, or in other words, no two parameter
blocks in in the first elimination group should co-occur in the same
residual block. For the best performance, this elimination group
should be as large as possible. For standard bundle adjustment
problems, this corresponds to the first elimination group containing
all the 3d points, and the second containing the all the cameras
parameter blocks.</p>
<p>If the user leaves the choice to Ceres, then the solver uses an
approximate maximum independent set algorithm to identify the first
elimination group <a class="reference internal" href="bibliography.html#lisaad" id="id35">[LiSaad]</a>.</p>
</div>
<div class="section" id="solver-options">
<span id="section-solver-options"></span><h3><a class="reference internal" href="#Solver::Options" title="Solver::Options"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Solver::Options</span></tt></a><a class="headerlink" href="#solver-options" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="Solver::Options">
<em class="property">class </em><tt class="descclassname">Solver::</tt><tt class="descname">Options</tt><a class="headerlink" href="#Solver::Options" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Solver::Options" title="Solver::Options"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Solver::Options</span></tt></a> controls the overall behavior of the
solver. We list the various settings and their default values below.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::minimizer_type__MinimizerType">
MinimizerType <tt class="descclassname">Solver::Options::</tt><tt class="descname">minimizer_type</tt><a class="headerlink" href="#Solver::Options::minimizer_type__MinimizerType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">TRUST_REGION</span></tt></p>
<p>Choose between <tt class="docutils literal"><span class="pre">LINE_SEARCH</span></tt> and <tt class="docutils literal"><span class="pre">TRUST_REGION</span></tt> algorithms. See
<a class="reference internal" href="#section-trust-region-methods"><em>Trust Region Methods</em></a> and
<a class="reference internal" href="#section-line-search-methods"><em>Line Search Methods</em></a> for more details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::line_search_direction_type__LineSearchDirectionType">
LineSearchDirectionType <tt class="descclassname">Solver::Options::</tt><tt class="descname">line_search_direction_type</tt><a class="headerlink" href="#Solver::Options::line_search_direction_type__LineSearchDirectionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">LBFGS</span></tt></p>
<p>Choices are <tt class="docutils literal"><span class="pre">STEEPEST_DESCENT</span></tt>, <tt class="docutils literal"><span class="pre">NONLINEAR_CONJUGATE_GRADIENT</span></tt>,
<tt class="docutils literal"><span class="pre">BFGS</span></tt> and <tt class="docutils literal"><span class="pre">LBFGS</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::line_search_type__LineSearchType">
LineSearchType <tt class="descclassname">Solver::Options::</tt><tt class="descname">line_search_type</tt><a class="headerlink" href="#Solver::Options::line_search_type__LineSearchType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">WOLFE</span></tt></p>
<p>Choices are <tt class="docutils literal"><span class="pre">ARMIJO</span></tt> and <tt class="docutils literal"><span class="pre">WOLFE</span></tt> (strong Wolfe conditions).
Note that in order for the assumptions underlying the <tt class="docutils literal"><span class="pre">BFGS</span></tt> and
<tt class="docutils literal"><span class="pre">LBFGS</span></tt> line search direction algorithms to be guaranteed to be
satisifed, the <tt class="docutils literal"><span class="pre">WOLFE</span></tt> line search should be used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::nonlinear_conjugate_gradient_type__NonlinearConjugateGradientType">
NonlinearConjugateGradientType <tt class="descclassname">Solver::Options::</tt><tt class="descname">nonlinear_conjugate_gradient_type</tt><a class="headerlink" href="#Solver::Options::nonlinear_conjugate_gradient_type__NonlinearConjugateGradientType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">FLETCHER_REEVES</span></tt></p>
<p>Choices are <tt class="docutils literal"><span class="pre">FLETCHER_REEVES</span></tt>, <tt class="docutils literal"><span class="pre">POLAK_RIBIRERE</span></tt> and
<tt class="docutils literal"><span class="pre">HESTENES_STIEFEL</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_lbfs_rank__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_lbfs_rank</tt><a class="headerlink" href="#Solver::Options::max_lbfs_rank__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: 20</p>
<p>The L-BFGS hessian approximation is a low rank approximation to the
inverse of the Hessian matrix. The rank of the approximation
determines (linearly) the space and time complexity of using the
approximation. Higher the rank, the better is the quality of the
approximation. The increase in quality is however is bounded for a
number of reasons.</p>
<blockquote>
<div><ol class="arabic simple">
<li>The method only uses secant information and not actual
derivatives.</li>
<li>The Hessian approximation is constrained to be positive
definite.</li>
</ol>
</div></blockquote>
<p>So increasing this rank to a large number will cost time and space
complexity without the corresponding increase in solution
quality. There are no hard and fast rules for choosing the maximum
rank. The best choice usually requires some problem specific
experimentation.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::use_approximate_eigenvalue_bfgs_scaling__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">use_approximate_eigenvalue_bfgs_scaling</tt><a class="headerlink" href="#Solver::Options::use_approximate_eigenvalue_bfgs_scaling__b" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>As part of the <tt class="docutils literal"><span class="pre">BFGS</span></tt> update step / <tt class="docutils literal"><span class="pre">LBFGS</span></tt> right-multiply
step, the initial inverse Hessian approximation is taken to be the
Identity.  However, <a class="reference internal" href="bibliography.html#oren" id="id36">[Oren]</a> showed that using instead <span class="math">\(I *
\gamma\)</span>, where <span class="math">\(\gamma\)</span> is a scalar chosen to approximate an
eigenvalue of the true inverse Hessian can result in improved
convergence in a wide variety of cases.  Setting
<tt class="docutils literal"><span class="pre">use_approximate_eigenvalue_bfgs_scaling</span></tt> to true enables this
scaling in <tt class="docutils literal"><span class="pre">BFGS</span></tt> (before first iteration) and <tt class="docutils literal"><span class="pre">LBFGS</span></tt> (at each
iteration).</p>
<p>Precisely, approximate eigenvalue scaling equates to</p>
<div class="math">
\[\gamma = \frac{y_k' s_k}{y_k' y_k}\]</div>
<p>With:</p>
</div></blockquote>
<div class="math">
\[y_k = \nabla f_{k+1} - \nabla f_k\]</div>
<div class="math">
\[s_k = x_{k+1} - x_k\]</div>
<p>Where <span class="math">\(f()\)</span> is the line search objective and <span class="math">\(x\)</span> the
vector of parameter values <a class="reference internal" href="bibliography.html#nocedalwright" id="id37">[NocedalWright]</a>.</p>
<p>It is important to note that approximate eigenvalue scaling does
<strong>not</strong> <em>always</em> improve convergence, and that it can in fact
<em>significantly</em> degrade performance for certain classes of problem,
which is why it is disabled by default.  In particular it can
degrade performance when the sensitivity of the problem to different
parameters varies significantly, as in this case a single scalar
factor fails to capture this variation and detrimentally downscales
parts of the Jacobian approximation which correspond to
low-sensitivity parameters. It can also reduce the robustness of the
solution to errors in the Jacobians.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::line_search_interpolation_type__LineSearchIterpolationType">
LineSearchIterpolationType <tt class="descclassname">Solver::Options::</tt><tt class="descname">line_search_interpolation_type</tt><a class="headerlink" href="#Solver::Options::line_search_interpolation_type__LineSearchIterpolationType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">CUBIC</span></tt></p>
<p>Degree of the polynomial used to approximate the objective
function. Valid values are <tt class="docutils literal"><span class="pre">BISECTION</span></tt>, <tt class="docutils literal"><span class="pre">QUADRATIC</span></tt> and
<tt class="docutils literal"><span class="pre">CUBIC</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::min_line_search_step_size__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">min_line_search_step_size</tt><a class="headerlink" href="#Solver::Options::min_line_search_step_size__double" title="Permalink to this definition">¶</a></dt>
<dd><p>The line search terminates if:</p>
<div class="math">
\[\begin{split}\|\Delta x_k\|_\infty &lt; \text{min_line_search_step_size}\end{split}\]</div>
<p>where <span class="math">\(\|\cdot\|_\infty\)</span> refers to the max norm, and
<span class="math">\(\Delta x_k\)</span> is the step change in the parameter values at
the <span class="math">\(k\)</span>-th iteration.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::line_search_sufficient_function_decrease__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">line_search_sufficient_function_decrease</tt><a class="headerlink" href="#Solver::Options::line_search_sufficient_function_decrease__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-4</span></tt></p>
<p>Solving the line search problem exactly is computationally
prohibitive. Fortunately, line search based optimization algorithms
can still guarantee convergence if instead of an exact solution,
the line search algorithm returns a solution which decreases the
value of the objective function sufficiently. More precisely, we
are looking for a step size s.t.</p>
<div class="math">
\[f(\text{step_size}) \le f(0) + \text{sufficient_decrease} * [f'(0) * \text{step_size}]\]</div>
<p>This condition is known as the Armijo condition.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_line_search_step_contraction__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_line_search_step_contraction</tt><a class="headerlink" href="#Solver::Options::max_line_search_step_contraction__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-3</span></tt></p>
<p>In each iteration of the line search,</p>
<div class="math">
\[\begin{split}\text{new_step_size} &gt;= \text{max_line_search_step_contraction} * \text{step_size}\end{split}\]</div>
<p>Note that by definition, for contraction:</p>
<div class="math">
\[\begin{split}0 &lt; \text{max_step_contraction} &lt; \text{min_step_contraction} &lt; 1\end{split}\]</div>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::min_line_search_step_contraction__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">min_line_search_step_contraction</tt><a class="headerlink" href="#Solver::Options::min_line_search_step_contraction__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">0.6</span></tt></p>
<p>In each iteration of the line search,</p>
<div class="math">
\[\begin{split}\text{new_step_size} &lt;= \text{min_line_search_step_contraction} * \text{step_size}\end{split}\]</div>
<p>Note that by definition, for contraction:</p>
<div class="math">
\[\begin{split}0 &lt; \text{max_step_contraction} &lt; \text{min_step_contraction} &lt; 1\end{split}\]</div>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_num_line_search_step_size_iterations__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_num_line_search_step_size_iterations</tt><a class="headerlink" href="#Solver::Options::max_num_line_search_step_size_iterations__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">20</span></tt></p>
<p>Maximum number of trial step size iterations during each line
search, if a step size satisfying the search conditions cannot be
found within this number of trials, the line search will stop.</p>
<p>As this is an &#8216;artificial&#8217; constraint (one imposed by the user, not
the underlying math), if <tt class="docutils literal"><span class="pre">WOLFE</span></tt> line search is being used, <em>and</em>
points satisfying the Armijo sufficient (function) decrease
condition have been found during the current search (in <span class="math">\(&lt;=\)</span>
<tt class="docutils literal"><span class="pre">max_num_line_search_step_size_iterations</span></tt>).  Then, the step size
with the lowest function value which satisfies the Armijo condition
will be returned as the new valid step, even though it does <em>not</em>
satisfy the strong Wolfe conditions.  This behaviour protects
against early termination of the optimizer at a sub-optimal point.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_num_line_search_direction_restarts__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_num_line_search_direction_restarts</tt><a class="headerlink" href="#Solver::Options::max_num_line_search_direction_restarts__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">5</span></tt></p>
<p>Maximum number of restarts of the line search direction algorithm
before terminating the optimization. Restarts of the line search
direction algorithm occur when the current algorithm fails to
produce a new descent direction. This typically indicates a
numerical failure, or a breakdown in the validity of the
approximations used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::line_search_sufficient_curvature_decrease__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">line_search_sufficient_curvature_decrease</tt><a class="headerlink" href="#Solver::Options::line_search_sufficient_curvature_decrease__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">0.9</span></tt></p>
<p>The strong Wolfe conditions consist of the Armijo sufficient
decrease condition, and an additional requirement that the
step size be chosen s.t. the <em>magnitude</em> (&#8216;strong&#8217; Wolfe
conditions) of the gradient along the search direction
decreases sufficiently. Precisely, this second condition
is that we seek a step size s.t.</p>
<div class="math">
\[\begin{split}\|f'(\text{step_size})\| &lt;= \text{sufficient_curvature_decrease} * \|f'(0)\|\end{split}\]</div>
<p>Where <span class="math">\(f()\)</span> is the line search objective and <span class="math">\(f'()\)</span> is the derivative
of <span class="math">\(f\)</span> with respect to the step size: <span class="math">\(\frac{d f}{d~\text{step size}}\)</span>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_line_search_step_expansion__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_line_search_step_expansion</tt><a class="headerlink" href="#Solver::Options::max_line_search_step_expansion__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">10.0</span></tt></p>
<p>During the bracketing phase of a Wolfe line search, the step size
is increased until either a point satisfying the Wolfe conditions
is found, or an upper bound for a bracket containinqg a point
satisfying the conditions is found.  Precisely, at each iteration
of the expansion:</p>
<div class="math">
\[\begin{split}\text{new_step_size} &lt;= \text{max_step_expansion} * \text{step_size}\end{split}\]</div>
<p>By definition for expansion</p>
<div class="math">
\[\begin{split}\text{max_step_expansion} &gt; 1.0\end{split}\]</div>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::trust_region_strategy_type__TrustRegionStrategyType">
TrustRegionStrategyType <tt class="descclassname">Solver::Options::</tt><tt class="descname">trust_region_strategy_type</tt><a class="headerlink" href="#Solver::Options::trust_region_strategy_type__TrustRegionStrategyType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">LEVENBERG_MARQUARDT</span></tt></p>
<p>The trust region step computation algorithm used by
Ceres. Currently <tt class="docutils literal"><span class="pre">LEVENBERG_MARQUARDT</span></tt> and <tt class="docutils literal"><span class="pre">DOGLEG</span></tt> are the two
valid choices. See <a class="reference internal" href="#section-levenberg-marquardt"><em>Levenberg-Marquardt</em></a> and
<a class="reference internal" href="#section-dogleg"><em>Dogleg</em></a> for more details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::dogleg_type__DoglegType">
DoglegType <tt class="descclassname">Solver::Options::</tt><tt class="descname">dogleg_type</tt><a class="headerlink" href="#Solver::Options::dogleg_type__DoglegType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">TRADITIONAL_DOGLEG</span></tt></p>
<p>Ceres supports two different dogleg strategies.
<tt class="docutils literal"><span class="pre">TRADITIONAL_DOGLEG</span></tt> method by Powell and the <tt class="docutils literal"><span class="pre">SUBSPACE_DOGLEG</span></tt>
method described by <a class="reference internal" href="bibliography.html#byrdschnabel" id="id38">[ByrdSchnabel]</a> .  See <a class="reference internal" href="#section-dogleg"><em>Dogleg</em></a>
for more details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::use_nonmonotonic_steps__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">use_nonmonotonic_steps</tt><a class="headerlink" href="#Solver::Options::use_nonmonotonic_steps__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>Relax the requirement that the trust-region algorithm take strictly
decreasing steps. See <a class="reference internal" href="#section-non-monotonic-steps"><em>Non-monotonic Steps</em></a> for more
details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_consecutive_nonmonotonic_steps__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_consecutive_nonmonotonic_steps</tt><a class="headerlink" href="#Solver::Options::max_consecutive_nonmonotonic_steps__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">5</span></tt></p>
<p>The window size used by the step selection algorithm to accept
non-monotonic steps.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_num_iterations__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_num_iterations</tt><a class="headerlink" href="#Solver::Options::max_num_iterations__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">50</span></tt></p>
<p>Maximum number of iterations for which the solver should run.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_solver_time_in_seconds__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_solver_time_in_seconds</tt><a class="headerlink" href="#Solver::Options::max_solver_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e6</span></tt>
Maximum amount of time for which the solver should run.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::num_threads__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">num_threads</tt><a class="headerlink" href="#Solver::Options::num_threads__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1</span></tt></p>
<p>Number of threads used by Ceres to evaluate the Jacobian.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::initial_trust_region_radius__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">initial_trust_region_radius</tt><a class="headerlink" href="#Solver::Options::initial_trust_region_radius__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e4</span></tt></p>
<p>The size of the initial trust region. When the
<tt class="docutils literal"><span class="pre">LEVENBERG_MARQUARDT</span></tt> strategy is used, the reciprocal of this
number is the initial regularization parameter.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_trust_region_radius__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_trust_region_radius</tt><a class="headerlink" href="#Solver::Options::max_trust_region_radius__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e16</span></tt></p>
<p>The trust region radius is not allowed to grow beyond this value.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::min_trust_region_radius__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">min_trust_region_radius</tt><a class="headerlink" href="#Solver::Options::min_trust_region_radius__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-32</span></tt></p>
<p>The solver terminates, when the trust region becomes smaller than
this value.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::min_relative_decrease__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">min_relative_decrease</tt><a class="headerlink" href="#Solver::Options::min_relative_decrease__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-3</span></tt></p>
<p>Lower threshold for relative decrease before a trust-region step is
accepted.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::min_lm_diagonal__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">min_lm_diagonal</tt><a class="headerlink" href="#Solver::Options::min_lm_diagonal__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e6</span></tt></p>
<p>The <tt class="docutils literal"><span class="pre">LEVENBERG_MARQUARDT</span></tt> strategy, uses a diagonal matrix to
regularize the the trust region step. This is the lower bound on
the values of this diagonal matrix.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_lm_diagonal__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_lm_diagonal</tt><a class="headerlink" href="#Solver::Options::max_lm_diagonal__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default:  <tt class="docutils literal"><span class="pre">1e32</span></tt></p>
<p>The <tt class="docutils literal"><span class="pre">LEVENBERG_MARQUARDT</span></tt> strategy, uses a diagonal matrix to
regularize the the trust region step. This is the upper bound on
the values of this diagonal matrix.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_num_consecutive_invalid_steps__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_num_consecutive_invalid_steps</tt><a class="headerlink" href="#Solver::Options::max_num_consecutive_invalid_steps__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">5</span></tt></p>
<p>The step returned by a trust region strategy can sometimes be
numerically invalid, usually because of conditioning
issues. Instead of crashing or stopping the optimization, the
optimizer can go ahead and try solving with a smaller trust
region/better conditioned problem. This parameter sets the number
of consecutive retries before the minimizer gives up.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::function_tolerance__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">function_tolerance</tt><a class="headerlink" href="#Solver::Options::function_tolerance__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-6</span></tt></p>
<p>Solver terminates if</p>
<div class="math">
\[\begin{split}\frac{|\Delta \text{cost}|}{\text{cost} &lt; \text{function_tolerance}}\end{split}\]</div>
<p>where, <span class="math">\(\Delta \text{cost}\)</span> is the change in objective
function value (up or down) in the current iteration of
Levenberg-Marquardt.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::gradient_tolerance__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">gradient_tolerance</tt><a class="headerlink" href="#Solver::Options::gradient_tolerance__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-10</span></tt></p>
<p>Solver terminates if</p>
<div class="math">
\[\begin{split}\|x - \Pi \boxplus(x, -g(x))\|_\infty &lt; \text{gradient_tolerance}\end{split}\]</div>
<p>where <span class="math">\(\|\cdot\|_\infty\)</span> refers to the max norm, <span class="math">\(\Pi\)</span>
is projection onto the bounds constraints and <span class="math">\(\boxplus\)</span> is
Plus operation for the overall local parameterization associated
with the parameter vector.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::parameter_tolerance__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">parameter_tolerance</tt><a class="headerlink" href="#Solver::Options::parameter_tolerance__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-8</span></tt></p>
<p>Solver terminates if</p>
<div class="math">
\[\begin{split}\|\Delta x\| &lt; (\|x\| + \text{parameter_tolerance}) * \text{parameter_tolerance}\end{split}\]</div>
<p>where <span class="math">\(\Delta x\)</span> is the step computed by the linear solver in
the current iteration of Levenberg-Marquardt.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::linear_solver_type__LinearSolverType">
LinearSolverType <tt class="descclassname">Solver::Options::</tt><tt class="descname">linear_solver_type</tt><a class="headerlink" href="#Solver::Options::linear_solver_type__LinearSolverType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">SPARSE_NORMAL_CHOLESKY</span></tt> / <tt class="docutils literal"><span class="pre">DENSE_QR</span></tt></p>
<p>Type of linear solver used to compute the solution to the linear
least squares problem in each iteration of the Levenberg-Marquardt
algorithm. If Ceres is build with <tt class="docutils literal"><span class="pre">SuiteSparse</span></tt> linked in then
the default is <tt class="docutils literal"><span class="pre">SPARSE_NORMAL_CHOLESKY</span></tt>, it is <tt class="docutils literal"><span class="pre">DENSE_QR</span></tt>
otherwise.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::preconditioner_type__PreconditionerType">
PreconditionerType <tt class="descclassname">Solver::Options::</tt><tt class="descname">preconditioner_type</tt><a class="headerlink" href="#Solver::Options::preconditioner_type__PreconditionerType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">JACOBI</span></tt></p>
<p>The preconditioner used by the iterative linear solver. The default
is the block Jacobi preconditioner. Valid values are (in increasing
order of complexity) <tt class="docutils literal"><span class="pre">IDENTITY</span></tt>, <tt class="docutils literal"><span class="pre">JACOBI</span></tt>, <tt class="docutils literal"><span class="pre">SCHUR_JACOBI</span></tt>,
<tt class="docutils literal"><span class="pre">CLUSTER_JACOBI</span></tt> and <tt class="docutils literal"><span class="pre">CLUSTER_TRIDIAGONAL</span></tt>. See
<a class="reference internal" href="#section-preconditioner"><em>Preconditioner</em></a> for more details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::visibility_clustering_type__VisibilityClusteringType">
VisibilityClusteringType <tt class="descclassname">Solver::Options::</tt><tt class="descname">visibility_clustering_type</tt><a class="headerlink" href="#Solver::Options::visibility_clustering_type__VisibilityClusteringType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">CANONICAL_VIEWS</span></tt></p>
<p>Type of clustering algorithm to use when constructing a visibility
based preconditioner. The original visibility based preconditioning
paper and implementation only used the canonical views algorithm.</p>
<p>This algorithm gives high quality results but for large dense
graphs can be particularly expensive. As its worst case complexity
is cubic in size of the graph.</p>
<p>Another option is to use <tt class="docutils literal"><span class="pre">SINGLE_LINKAGE</span></tt> which is a simple
thresholded single linkage clustering algorithm that only pays
attention to tightly coupled blocks in the Schur complement. This
is a fast algorithm that works well.</p>
<p>The optimal choice of the clustering algorithm depends on the
sparsity structure of the problem, but generally speaking we
recommend that you try <tt class="docutils literal"><span class="pre">CANONICAL_VIEWS</span></tt> first and if it is too
expensive try <tt class="docutils literal"><span class="pre">SINGLE_LINKAGE</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::dense_linear_algebra_library_type__DenseLinearAlgebraLibrary">
DenseLinearAlgebraLibrary <tt class="descclassname">Solver::Options::</tt><tt class="descname">dense_linear_algebra_library_type</tt><a class="headerlink" href="#Solver::Options::dense_linear_algebra_library_type__DenseLinearAlgebraLibrary" title="Permalink to this definition">¶</a></dt>
<dd><p>Default:<tt class="docutils literal"><span class="pre">EIGEN</span></tt></p>
<p>Ceres supports using multiple dense linear algebra libraries for
dense matrix factorizations. Currently <tt class="docutils literal"><span class="pre">EIGEN</span></tt> and <tt class="docutils literal"><span class="pre">LAPACK</span></tt> are
the valid choices. <tt class="docutils literal"><span class="pre">EIGEN</span></tt> is always available, <tt class="docutils literal"><span class="pre">LAPACK</span></tt> refers
to the system <tt class="docutils literal"><span class="pre">BLAS</span> <span class="pre">+</span> <span class="pre">LAPACK</span></tt> library which may or may not be
available.</p>
<p>This setting affects the <tt class="docutils literal"><span class="pre">DENSE_QR</span></tt>, <tt class="docutils literal"><span class="pre">DENSE_NORMAL_CHOLESKY</span></tt>
and <tt class="docutils literal"><span class="pre">DENSE_SCHUR</span></tt> solvers. For small to moderate sized probem
<tt class="docutils literal"><span class="pre">EIGEN</span></tt> is a fine choice but for large problems, an optimized
<tt class="docutils literal"><span class="pre">LAPACK</span> <span class="pre">+</span> <span class="pre">BLAS</span></tt> implementation can make a substantial difference
in performance.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::sparse_linear_algebra_library_type__SparseLinearAlgebraLibrary">
SparseLinearAlgebraLibrary <tt class="descclassname">Solver::Options::</tt><tt class="descname">sparse_linear_algebra_library_type</tt><a class="headerlink" href="#Solver::Options::sparse_linear_algebra_library_type__SparseLinearAlgebraLibrary" title="Permalink to this definition">¶</a></dt>
<dd><p>Default:<tt class="docutils literal"><span class="pre">SUITE_SPARSE</span></tt></p>
<p>Ceres supports the use of two sparse linear algebra libraries,
<tt class="docutils literal"><span class="pre">SuiteSparse</span></tt>, which is enabled by setting this parameter to
<tt class="docutils literal"><span class="pre">SUITE_SPARSE</span></tt> and <tt class="docutils literal"><span class="pre">CXSparse</span></tt>, which can be selected by setting
this parameter to <tt class="docutils literal"><span class="pre">`CX_SPARSE</span></tt>. <tt class="docutils literal"><span class="pre">SuiteSparse</span></tt> is a
sophisticated and complex sparse linear algebra library and should
be used in general. If your needs/platforms prevent you from using
<tt class="docutils literal"><span class="pre">SuiteSparse</span></tt>, consider using <tt class="docutils literal"><span class="pre">CXSparse</span></tt>, which is a much
smaller, easier to build library. As can be expected, its
performance on large problems is not comparable to that of
<tt class="docutils literal"><span class="pre">SuiteSparse</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::num_linear_solver_threads__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">num_linear_solver_threads</tt><a class="headerlink" href="#Solver::Options::num_linear_solver_threads__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1</span></tt></p>
<p>Number of threads used by the linear solver.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::linear_solver_ordering__shared_ptr:ParameterBlockOrdering:">
shared_ptr&lt;ParameterBlockOrdering&gt; <tt class="descclassname">Solver::Options::</tt><tt class="descname">linear_solver_ordering</tt><a class="headerlink" href="#Solver::Options::linear_solver_ordering__shared_ptr:ParameterBlockOrdering:" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">NULL</span></tt></p>
<p>An instance of the ordering object informs the solver about the
desired order in which parameter blocks should be eliminated by the
linear solvers. See section~ref{sec:ordering`` for more details.</p>
<p>If <tt class="docutils literal"><span class="pre">NULL</span></tt>, the solver is free to choose an ordering that it
thinks is best.</p>
<p>See <a class="reference internal" href="#section-ordering"><em>Ordering</em></a> for more details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::use_post_ordering__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">use_post_ordering</tt><a class="headerlink" href="#Solver::Options::use_post_ordering__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>Sparse Cholesky factorization algorithms use a fill-reducing
ordering to permute the columns of the Jacobian matrix. There are
two ways of doing this.</p>
<ol class="arabic simple">
<li>Compute the Jacobian matrix in some order and then have the
factorization algorithm permute the columns of the Jacobian.</li>
<li>Compute the Jacobian with its columns already permuted.</li>
</ol>
<p>The first option incurs a significant memory penalty. The
factorization algorithm has to make a copy of the permuted Jacobian
matrix, thus Ceres pre-permutes the columns of the Jacobian matrix
and generally speaking, there is no performance penalty for doing
so.</p>
<p>In some rare cases, it is worth using a more complicated reordering
algorithm which has slightly better runtime performance at the
expense of an extra copy of the Jacobian matrix. Setting
<tt class="docutils literal"><span class="pre">use_postordering</span></tt> to <tt class="docutils literal"><span class="pre">true</span></tt> enables this tradeoff.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::dynamic_sparsity__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">dynamic_sparsity</tt><a class="headerlink" href="#Solver::Options::dynamic_sparsity__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Some non-linear least squares problems are symbolically dense but
numerically sparse. i.e. at any given state only a small number of
Jacobian entries are non-zero, but the position and number of
non-zeros is different depending on the state. For these problems
it can be useful to factorize the sparse jacobian at each solver
iteration instead of including all of the zero entries in a single
general factorization.</p>
<p>If your problem does not have this property (or you do not know),
then it is probably best to keep this false, otherwise it will
likely lead to worse performance.</p>
<p>This settings affects the <cite>SPARSE_NORMAL_CHOLESKY</cite> solver.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::min_linear_solver_iterations__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">min_linear_solver_iterations</tt><a class="headerlink" href="#Solver::Options::min_linear_solver_iterations__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1</span></tt></p>
<p>Minimum number of iterations used by the linear solver. This only
makes sense when the linear solver is an iterative solver, e.g.,
<tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt> or <tt class="docutils literal"><span class="pre">CGNR</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::max_linear_solver_iterations__i">
int <tt class="descclassname">Solver::Options::</tt><tt class="descname">max_linear_solver_iterations</tt><a class="headerlink" href="#Solver::Options::max_linear_solver_iterations__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">500</span></tt></p>
<p>Minimum number of iterations used by the linear solver. This only
makes sense when the linear solver is an iterative solver, e.g.,
<tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt> or <tt class="docutils literal"><span class="pre">CGNR</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::eta__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">eta</tt><a class="headerlink" href="#Solver::Options::eta__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-1</span></tt></p>
<p>Forcing sequence parameter. The truncated Newton solver uses this
number to control the relative accuracy with which the Newton step
is computed. This constant is passed to
<tt class="docutils literal"><span class="pre">ConjugateGradientsSolver</span></tt> which uses it to terminate the
iterations when</p>
<div class="math">
\[\begin{split}\frac{Q_i - Q_{i-1}}{Q_i} &lt; \frac{\eta}{i}\end{split}\]</div>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::jacobi_scaling__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">jacobi_scaling</tt><a class="headerlink" href="#Solver::Options::jacobi_scaling__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">true</span></tt></p>
<p><tt class="docutils literal"><span class="pre">true</span></tt> means that the Jacobian is scaled by the norm of its
columns before being passed to the linear solver. This improves the
numerical conditioning of the normal equations.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::use_inner_iterations__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">use_inner_iterations</tt><a class="headerlink" href="#Solver::Options::use_inner_iterations__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>Use a non-linear version of a simplified variable projection
algorithm. Essentially this amounts to doing a further optimization
on each Newton/Trust region step using a coordinate descent
algorithm.  For more details, see <a class="reference internal" href="#section-inner-iterations"><em>Inner Iterations</em></a>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::inner_itearation_tolerance__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">inner_itearation_tolerance</tt><a class="headerlink" href="#Solver::Options::inner_itearation_tolerance__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-3</span></tt></p>
<p>Generally speaking, inner iterations make significant progress in
the early stages of the solve and then their contribution drops
down sharply, at which point the time spent doing inner iterations
is not worth it.</p>
<p>Once the relative decrease in the objective function due to inner
iterations drops below <tt class="docutils literal"><span class="pre">inner_iteration_tolerance</span></tt>, the use of
inner iterations in subsequent trust region minimizer iterations is
disabled.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::inner_iteration_ordering__shared_ptr:ParameterBlockOrdering:">
shared_ptr&lt;ParameterBlockOrdering&gt; <tt class="descclassname">Solver::Options::</tt><tt class="descname">inner_iteration_ordering</tt><a class="headerlink" href="#Solver::Options::inner_iteration_ordering__shared_ptr:ParameterBlockOrdering:" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">NULL</span></tt></p>
<p>If <a class="reference internal" href="#Solver::Options::use_inner_iterations__b" title="Solver::Options::use_inner_iterations"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::use_inner_iterations</span></tt></a> true, then the
user has two choices.</p>
<ol class="arabic simple">
<li>Let the solver heuristically decide which parameter blocks to
optimize in each inner iteration. To do this, set
<a class="reference internal" href="#Solver::Options::inner_iteration_ordering__shared_ptr:ParameterBlockOrdering:" title="Solver::Options::inner_iteration_ordering"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::inner_iteration_ordering</span></tt></a> to <tt class="docutils literal"><span class="pre">NULL</span></tt>.</li>
<li>Specify a collection of of ordered independent sets. The lower
numbered groups are optimized before the higher number groups
during the inner optimization phase. Each group must be an
independent set. Not all parameter blocks need to be included in
the ordering.</li>
</ol>
<p>See <a class="reference internal" href="#section-ordering"><em>Ordering</em></a> for more details.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::logging_type__LoggingType">
LoggingType <tt class="descclassname">Solver::Options::</tt><tt class="descname">logging_type</tt><a class="headerlink" href="#Solver::Options::logging_type__LoggingType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">PER_MINIMIZER_ITERATION</span></tt></p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::minimizer_progress_to_stdout__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">minimizer_progress_to_stdout</tt><a class="headerlink" href="#Solver::Options::minimizer_progress_to_stdout__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>By default the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Minimizer</span></tt> progress is logged to <tt class="docutils literal"><span class="pre">STDERR</span></tt>
depending on the <tt class="docutils literal"><span class="pre">vlog</span></tt> level. If this flag is set to true, and
<a class="reference internal" href="#Solver::Options::logging_type__LoggingType" title="Solver::Options::logging_type"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::logging_type</span></tt></a> is not <tt class="docutils literal"><span class="pre">SILENT</span></tt>, the logging
output is sent to <tt class="docutils literal"><span class="pre">STDOUT</span></tt>.</p>
<p>For <tt class="docutils literal"><span class="pre">TRUST_REGION_MINIMIZER</span></tt> the progress display looks like</p>
<div class="highlight-bash"><div class="highlight"><pre>0: f: 1.250000e+01 d: 0.00e+00 g: 5.00e+00 h: 0.00e+00 rho: 0.00e+00 mu: 1.00e+04 li:  0 it: 6.91e-06 tt: 1.91e-03
1: f: 1.249750e-07 d: 1.25e+01 g: 5.00e-04 h: 5.00e+00 rho: 1.00e+00 mu: 3.00e+04 li:  1 it: 2.81e-05 tt: 1.99e-03
2: f: 1.388518e-16 d: 1.25e-07 g: 1.67e-08 h: 5.00e-04 rho: 1.00e+00 mu: 9.00e+04 li:  1 it: 1.00e-05 tt: 2.01e-03
</pre></div>
</div>
<p>Here</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> is the value of the objective function.</li>
<li><tt class="docutils literal"><span class="pre">d</span></tt> is the change in the value of the objective function if
the step computed in this iteration is accepted.</li>
<li><tt class="docutils literal"><span class="pre">g</span></tt> is the max norm of the gradient.</li>
<li><tt class="docutils literal"><span class="pre">h</span></tt> is the change in the parameter vector.</li>
<li><tt class="docutils literal"><span class="pre">rho</span></tt> is the ratio of the actual change in the objective
function value to the change in the the value of the trust
region model.</li>
<li><tt class="docutils literal"><span class="pre">mu</span></tt> is the size of the trust region radius.</li>
<li><tt class="docutils literal"><span class="pre">li</span></tt> is the number of linear solver iterations used to compute
the trust region step. For direct/factorization based solvers it
is always 1, for iterative solvers like <tt class="docutils literal"><span class="pre">ITERATIVE_SCHUR</span></tt> it
is the number of iterations of the Conjugate Gradients
algorithm.</li>
<li><tt class="docutils literal"><span class="pre">it</span></tt> is the time take by the current iteration.</li>
<li><tt class="docutils literal"><span class="pre">tt</span></tt> is the the total time taken by the minimizer.</li>
</ol>
<p>For <tt class="docutils literal"><span class="pre">LINE_SEARCH_MINIMIZER</span></tt> the progress display looks like</p>
<div class="highlight-bash"><div class="highlight"><pre>0: f: 2.317806e+05 d: 0.00e+00 g: 3.19e-01 h: 0.00e+00 s: 0.00e+00 e:  0 it: 2.98e-02 tt: 8.50e-02
1: f: 2.312019e+05 d: 5.79e+02 g: 3.18e-01 h: 2.41e+01 s: 1.00e+00 e:  1 it: 4.54e-02 tt: 1.31e-01
2: f: 2.300462e+05 d: 1.16e+03 g: 3.17e-01 h: 4.90e+01 s: 2.54e-03 e:  1 it: 4.96e-02 tt: 1.81e-01
</pre></div>
</div>
<p>Here</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> is the value of the objective function.</li>
<li><tt class="docutils literal"><span class="pre">d</span></tt> is the change in the value of the objective function if
the step computed in this iteration is accepted.</li>
<li><tt class="docutils literal"><span class="pre">g</span></tt> is the max norm of the gradient.</li>
<li><tt class="docutils literal"><span class="pre">h</span></tt> is the change in the parameter vector.</li>
<li><tt class="docutils literal"><span class="pre">s</span></tt> is the optimal step length computed by the line search.</li>
<li><tt class="docutils literal"><span class="pre">it</span></tt> is the time take by the current iteration.</li>
<li><tt class="docutils literal"><span class="pre">tt</span></tt> is the the total time taken by the minimizer.</li>
</ol>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::trust_region_minimizer_iterations_to_dump__vector:i:">
vector&lt;int&gt; <tt class="descclassname">Solver::Options::</tt><tt class="descname">trust_region_minimizer_iterations_to_dump</tt><a class="headerlink" href="#Solver::Options::trust_region_minimizer_iterations_to_dump__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">empty</span></tt></p>
<p>List of iterations at which the trust region minimizer should dump
the trust region problem. Useful for testing and benchmarking. If
<tt class="docutils literal"><span class="pre">empty</span></tt>, no problems are dumped.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::trust_region_problem_dump_directory__string">
string <tt class="descclassname">Solver::Options::</tt><tt class="descname">trust_region_problem_dump_directory</tt><a class="headerlink" href="#Solver::Options::trust_region_problem_dump_directory__string" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">/tmp</span></tt></p>
<blockquote>
<div>Directory to which the problems should be written to. Should be
non-empty if
<a class="reference internal" href="#Solver::Options::trust_region_minimizer_iterations_to_dump__vector:i:" title="Solver::Options::trust_region_minimizer_iterations_to_dump"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::trust_region_minimizer_iterations_to_dump</span></tt></a> is
non-empty and
<tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::trust_region_problem_dump_format_type</span></tt> is not
<tt class="docutils literal"><span class="pre">CONSOLE</span></tt>.</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::trust_region_problem_dump_format__DumpFormatType">
DumpFormatType <tt class="descclassname">Solver::Options::</tt><tt class="descname">trust_region_problem_dump_format</tt><a class="headerlink" href="#Solver::Options::trust_region_problem_dump_format__DumpFormatType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">TEXTFILE</span></tt></p>
<p>The format in which trust region problems should be logged when
<a class="reference internal" href="#Solver::Options::trust_region_minimizer_iterations_to_dump__vector:i:" title="Solver::Options::trust_region_minimizer_iterations_to_dump"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::trust_region_minimizer_iterations_to_dump</span></tt></a>
is non-empty.  There are three options:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">CONSOLE</span></tt> prints the linear least squares problem in a human</dt>
<dd><p class="first last">readable format to <tt class="docutils literal"><span class="pre">stderr</span></tt>. The Jacobian is printed as a
dense matrix. The vectors <span class="math">\(D\)</span>, <span class="math">\(x\)</span> and <span class="math">\(f\)</span> are
printed as dense vectors. This should only be used for small
problems.</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">TEXTFILE</span></tt> Write out the linear least squares problem to the
directory pointed to by
<a class="reference internal" href="#Solver::Options::trust_region_problem_dump_directory__string" title="Solver::Options::trust_region_problem_dump_directory"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::trust_region_problem_dump_directory</span></tt></a> as
text files which can be read into <tt class="docutils literal"><span class="pre">MATLAB/Octave</span></tt>. The Jacobian
is dumped as a text file containing <span class="math">\((i,j,s)\)</span> triplets, the
vectors <span class="math">\(D\)</span>, <cite>x</cite> and <cite>f</cite> are dumped as text files
containing a list of their values.</p>
<p>A <tt class="docutils literal"><span class="pre">MATLAB/Octave</span></tt> script called
<tt class="docutils literal"><span class="pre">ceres_solver_iteration_???.m</span></tt> is also output, which can be
used to parse and load the problem into memory.</p>
</li>
</ul>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::check_gradients__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">check_gradients</tt><a class="headerlink" href="#Solver::Options::check_gradients__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>Check all Jacobians computed by each residual block with finite
differences. This is expensive since it involves computing the
derivative by normal means (e.g. user specified, autodiff, etc),
then also computing it using finite differences. The results are
compared, and if they differ substantially, details are printed to
the log.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::gradient_check_relative_precision__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">gradient_check_relative_precision</tt><a class="headerlink" href="#Solver::Options::gradient_check_relative_precision__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e08</span></tt></p>
<p>Precision to check for in the gradient checker. If the relative
difference between an element in a Jacobian exceeds this number,
then the Jacobian for that cost term is dumped.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::numeric_derivative_relative_step_size__double">
double <tt class="descclassname">Solver::Options::</tt><tt class="descname">numeric_derivative_relative_step_size</tt><a class="headerlink" href="#Solver::Options::numeric_derivative_relative_step_size__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1e-6</span></tt></p>
<p>Relative shift used for taking numeric derivatives. For finite
differencing, each dimension is evaluated at slightly shifted
values, e.g., for forward differences, the numerical derivative is</p>
<div class="math">
\[\begin{split}\delta &amp;= numeric\_derivative\_relative\_step\_size\\
\Delta f &amp;= \frac{f((1 + \delta)  x) - f(x)}{\delta x}\end{split}\]</div>
<p>The finite differencing is done along each dimension. The reason to
use a relative (rather than absolute) step size is that this way,
numeric differentiation works for functions where the arguments are
typically large (e.g. <span class="math">\(10^9\)</span>) and when the values are small
(e.g. <span class="math">\(10^{-5}\)</span>). It is possible to construct <em>torture cases</em>
which break this finite difference heuristic, but they do not come
up often in practice.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::callbacks__vector:IterationCallback:">
vector&lt;IterationCallback&gt; <tt class="descclassname">Solver::Options::</tt><tt class="descname">callbacks</tt><a class="headerlink" href="#Solver::Options::callbacks__vector:IterationCallback:" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks that are executed at the end of each iteration of the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Minimizer</span></tt>. They are executed in the order that they are
specified in this vector. By default, parameter blocks are updated
only at the end of the optimization, i.e when the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Minimizer</span></tt> terminates. This behavior is controlled by
<tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::update_state_every_variable</span></tt>. If the user
wishes to have access to the update parameter blocks when his/her
callbacks are executed, then set
<a class="reference internal" href="#Solver::Options::update_state_every_iteration__b" title="Solver::Options::update_state_every_iteration"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::update_state_every_iteration</span></tt></a> to true.</p>
<p>The solver does NOT take ownership of these pointers.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::update_state_every_iteration__b">
bool <tt class="descclassname">Solver::Options::</tt><tt class="descname">update_state_every_iteration</tt><a class="headerlink" href="#Solver::Options::update_state_every_iteration__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">false</span></tt></p>
<p>Normally the parameter blocks are only updated when the solver
terminates. Setting this to true update them in every
iteration. This setting is useful when building an interactive
application using Ceres and using an <a class="reference internal" href="#IterationCallback" title="IterationCallback"><tt class="xref cpp cpp-class docutils literal"><span class="pre">IterationCallback</span></tt></a>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Options::solver_log__string">
string <tt class="descclassname">Solver::Options::</tt><tt class="descname">solver_log</tt><a class="headerlink" href="#Solver::Options::solver_log__string" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">empty</span></tt></p>
<p>If non-empty, a summary of the execution of the solver is recorded
to this file.  This file is used for recording and Ceres&#8217;
performance. Currently, only the iteration number, total time and
the objective function value are logged. The format of this file is
expected to change over time as the performance evaluation
framework is fleshed out.</p>
</dd></dl>

</div>
<div class="section" id="parameterblockordering">
<h3><a class="reference internal" href="#ParameterBlockOrdering" title="ParameterBlockOrdering"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ParameterBlockOrdering</span></tt></a><a class="headerlink" href="#parameterblockordering" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="ParameterBlockOrdering">
<em class="property">class </em><tt class="descname">ParameterBlockOrdering</tt><a class="headerlink" href="#ParameterBlockOrdering" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">ParameterBlockOrdering</span></tt> is a class for storing and manipulating
an ordered collection of groups/sets with the following semantics:</p>
<p>Group IDs are non-negative integer values. Elements are any type
that can serve as a key in a map or an element of a set.</p>
<p>An element can only belong to one group at a time. A group may
contain an arbitrary number of elements.</p>
<p>Groups are ordered by their group id.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::AddElementToGroup__doubleCP.iC">
bool <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">AddElementToGroup</tt><big>(</big>const double* <em>element</em>, const int <em>group</em><big>)</big><a class="headerlink" href="#ParameterBlockOrdering::AddElementToGroup__doubleCP.iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an element to a group. If a group with this id does not exist,
one is created. This method can be called any number of times for
the same element. Group ids should be non-negative numbers.  Return
value indicates if adding the element was a success.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::Clear">
void <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">Clear</tt><big>(</big><big>)</big><a class="headerlink" href="#ParameterBlockOrdering::Clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the ordering.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::Remove__doubleCP">
bool <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">Remove</tt><big>(</big>const double* <em>element</em><big>)</big><a class="headerlink" href="#ParameterBlockOrdering::Remove__doubleCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the element, no matter what group it is in. If the element
is not a member of any group, calling this method will result in a
crash.  Return value indicates if the element was actually removed.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::Reverse">
void <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">Reverse</tt><big>(</big><big>)</big><a class="headerlink" href="#ParameterBlockOrdering::Reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of the groups in place.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::GroupId__doubleCPC">
int <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">GroupId</tt><big>(</big>const double* <em>element</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ParameterBlockOrdering::GroupId__doubleCPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the group id for the element. If the element is not a member
of any group, return -1.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::IsMember__doubleCPC">
bool <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">IsMember</tt><big>(</big>const double* <em>element</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ParameterBlockOrdering::IsMember__doubleCPC" title="Permalink to this definition">¶</a></dt>
<dd><p>True if there is a group containing the parameter block.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::GroupSize__iCC">
int <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">GroupSize</tt><big>(</big>const int <em>group</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ParameterBlockOrdering::GroupSize__iCC" title="Permalink to this definition">¶</a></dt>
<dd><p>This function always succeeds, i.e., implicitly there exists a
group for every integer.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::NumElementsC">
int <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">NumElements</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ParameterBlockOrdering::NumElementsC" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of elements in the ordering.</p>
</dd></dl>

<dl class="function">
<dt id="ParameterBlockOrdering::NumGroupsC">
int <tt class="descclassname">ParameterBlockOrdering::</tt><tt class="descname">NumGroups</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ParameterBlockOrdering::NumGroupsC" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of groups with one or more elements.</p>
</dd></dl>

</div>
<div class="section" id="iterationcallback">
<h3><a class="reference internal" href="#IterationCallback" title="IterationCallback"><tt class="xref cpp cpp-class docutils literal"><span class="pre">IterationCallback</span></tt></a><a class="headerlink" href="#iterationcallback" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="IterationSummary">
<em class="property">class </em><tt class="descname">IterationSummary</tt><a class="headerlink" href="#IterationSummary" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#IterationSummary" title="IterationSummary"><tt class="xref cpp cpp-class docutils literal"><span class="pre">IterationSummary</span></tt></a> describes the state of the minimizer at
the end of each iteration.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::iteration__int32">
int32 <tt class="descclassname">IterationSummary::</tt><tt class="descname">iteration</tt><a class="headerlink" href="#IterationSummary::iteration__int32" title="Permalink to this definition">¶</a></dt>
<dd><p>Current iteration number.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::step_is_valid__b">
bool <tt class="descclassname">IterationSummary::</tt><tt class="descname">step_is_valid</tt><a class="headerlink" href="#IterationSummary::step_is_valid__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Step was numerically valid, i.e., all values are finite and the
step reduces the value of the linearized model.</p>
<blockquote>
<div><strong>Note</strong>: <a class="reference internal" href="#IterationSummary::step_is_valid__b" title="IterationSummary::step_is_valid"><tt class="xref cpp cpp-member docutils literal"><span class="pre">IterationSummary::step_is_valid</span></tt></a> is <cite>false</cite>
when <a class="reference internal" href="#IterationSummary::iteration__int32" title="IterationSummary::iteration"><tt class="xref cpp cpp-member docutils literal"><span class="pre">IterationSummary::iteration</span></tt></a> = 0.</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::step_is_nonmonotonic__b">
bool <tt class="descclassname">IterationSummary::</tt><tt class="descname">step_is_nonmonotonic</tt><a class="headerlink" href="#IterationSummary::step_is_nonmonotonic__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Step did not reduce the value of the objective function
sufficiently, but it was accepted because of the relaxed
acceptance criterion used by the non-monotonic trust region
algorithm.</p>
<p><strong>Note</strong>: <a class="reference internal" href="#IterationSummary::step_is_nonmonotonic__b" title="IterationSummary::step_is_nonmonotonic"><tt class="xref cpp cpp-member docutils literal"><span class="pre">IterationSummary::step_is_nonmonotonic</span></tt></a> is
<cite>false</cite> when when <a class="reference internal" href="#IterationSummary::iteration__int32" title="IterationSummary::iteration"><tt class="xref cpp cpp-member docutils literal"><span class="pre">IterationSummary::iteration</span></tt></a> = 0.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::step_is_successful__b">
bool <tt class="descclassname">IterationSummary::</tt><tt class="descname">step_is_successful</tt><a class="headerlink" href="#IterationSummary::step_is_successful__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not the minimizer accepted this step or not.</p>
<p>If the ordinary trust region algorithm is used, this means that the
relative reduction in the objective function value was greater than
<a class="reference internal" href="#Solver::Options::min_relative_decrease__double" title="Solver::Options::min_relative_decrease"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::min_relative_decrease</span></tt></a>. However, if the
non-monotonic trust region algorithm is used
(<a class="reference internal" href="#Solver::Options::use_nonmonotonic_steps__b" title="Solver::Options::use_nonmonotonic_steps"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::use_nonmonotonic_steps</span></tt></a> = <cite>true</cite>), then
even if the relative decrease is not sufficient, the algorithm may
accept the step and the step is declared successful.</p>
<p><strong>Note</strong>: <a class="reference internal" href="#IterationSummary::step_is_successful__b" title="IterationSummary::step_is_successful"><tt class="xref cpp cpp-member docutils literal"><span class="pre">IterationSummary::step_is_successful</span></tt></a> is <cite>false</cite>
when when <a class="reference internal" href="#IterationSummary::iteration__int32" title="IterationSummary::iteration"><tt class="xref cpp cpp-member docutils literal"><span class="pre">IterationSummary::iteration</span></tt></a> = 0.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::cost__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">cost</tt><a class="headerlink" href="#IterationSummary::cost__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of the objective function.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::cost_change__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">cost_change</tt><a class="headerlink" href="#IterationSummary::cost_change__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Change in the value of the objective function in this
iteration. This can be positive or negative.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::gradient_max_norm__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">gradient_max_norm</tt><a class="headerlink" href="#IterationSummary::gradient_max_norm__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Infinity norm of the gradient vector.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::gradient_norm__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">gradient_norm</tt><a class="headerlink" href="#IterationSummary::gradient_norm__double" title="Permalink to this definition">¶</a></dt>
<dd><p>2-norm of the gradient vector.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::step_norm__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">step_norm</tt><a class="headerlink" href="#IterationSummary::step_norm__double" title="Permalink to this definition">¶</a></dt>
<dd><p>2-norm of the size of the step computed in this iteration.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::relative_decrease__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">relative_decrease</tt><a class="headerlink" href="#IterationSummary::relative_decrease__double" title="Permalink to this definition">¶</a></dt>
<dd><p>For trust region algorithms, the ratio of the actual change in cost
and the change in the cost of the linearized approximation.</p>
<p>This field is not used when a linear search minimizer is used.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::trust_region_radius__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">trust_region_radius</tt><a class="headerlink" href="#IterationSummary::trust_region_radius__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the trust region at the end of the current iteration. For
the Levenberg-Marquardt algorithm, the regularization parameter is
1.0 / member::<cite>IterationSummary::trust_region_radius</cite>.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::eta__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">eta</tt><a class="headerlink" href="#IterationSummary::eta__double" title="Permalink to this definition">¶</a></dt>
<dd><p>For the inexact step Levenberg-Marquardt algorithm, this is the
relative accuracy with which the step is solved. This number is
only applicable to the iterative solvers capable of solving linear
systems inexactly. Factorization-based exact solvers always have an
eta of 0.0.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::step_size__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">step_size</tt><a class="headerlink" href="#IterationSummary::step_size__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Step sized computed by the line search algorithm.</p>
<p>This field is not used when a trust region minimizer is used.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::line_search_function_evaluations__i">
int <tt class="descclassname">IterationSummary::</tt><tt class="descname">line_search_function_evaluations</tt><a class="headerlink" href="#IterationSummary::line_search_function_evaluations__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of function evaluations used by the line search algorithm.</p>
<p>This field is not used when a trust region minimizer is used.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::linear_solver_iterations__i">
int <tt class="descclassname">IterationSummary::</tt><tt class="descname">linear_solver_iterations</tt><a class="headerlink" href="#IterationSummary::linear_solver_iterations__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations taken by the linear solver to solve for the
trust region step.</p>
<p>Currently this field is not used when a line search minimizer is
used.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::iteration_time_in_seconds__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">iteration_time_in_seconds</tt><a class="headerlink" href="#IterationSummary::iteration_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent inside the minimizer loop in the current
iteration.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::step_solver_time_in_seconds__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">step_solver_time_in_seconds</tt><a class="headerlink" href="#IterationSummary::step_solver_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent inside the trust region step solver.</p>
</dd></dl>

<dl class="member">
<dt id="IterationSummary::cumulative_time_in_seconds__double">
double <tt class="descclassname">IterationSummary::</tt><tt class="descname">cumulative_time_in_seconds</tt><a class="headerlink" href="#IterationSummary::cumulative_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) since the user called Solve().</p>
</dd></dl>

<dl class="class">
<dt id="IterationCallback">
<em class="property">class </em><tt class="descname">IterationCallback</tt><a class="headerlink" href="#IterationCallback" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Interface for specifying callbacks that are executed at the end of
each iteration of the minimizer.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">IterationCallback</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">IterationCallback</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">CallbackReturnType</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">IterationSummary</span><span class="o">&amp;</span> <span class="n">summary</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>The solver uses the return value of <tt class="docutils literal"><span class="pre">operator()</span></tt> to decide whether
to continue solving or to terminate. The user can return three
values.</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">SOLVER_ABORT</span></tt> indicates that the callback detected an abnormal
situation. The solver returns without updating the parameter
blocks (unless <tt class="docutils literal"><span class="pre">Solver::Options::update_state_every_iteration</span></tt> is
set true). Solver returns with <tt class="docutils literal"><span class="pre">Solver::Summary::termination_type</span></tt>
set to <tt class="docutils literal"><span class="pre">USER_FAILURE</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">SOLVER_TERMINATE_SUCCESSFULLY</span></tt> indicates that there is no need
to optimize anymore (some user specified termination criterion
has been met). Solver returns with
<tt class="docutils literal"><span class="pre">Solver::Summary::termination_type`</span></tt> set to <tt class="docutils literal"><span class="pre">USER_SUCCESS</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">SOLVER_CONTINUE</span></tt> indicates that the solver should continue
optimizing.</li>
</ol>
<p>For example, the following <a class="reference internal" href="#IterationCallback" title="IterationCallback"><tt class="xref cpp cpp-class docutils literal"><span class="pre">IterationCallback</span></tt></a> is used
internally by Ceres to log the progress of the optimization.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LoggingCallback</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IterationCallback</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">LoggingCallback</span><span class="p">(</span><span class="kt">bool</span> <span class="n">log_to_stdout</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">log_to_stdout_</span><span class="p">(</span><span class="n">log_to_stdout</span><span class="p">)</span> <span class="p">{}</span>

  <span class="o">~</span><span class="n">LoggingCallback</span><span class="p">()</span> <span class="p">{}</span>

  <span class="n">CallbackReturnType</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">IterationSummary</span><span class="o">&amp;</span> <span class="n">summary</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">kReportRowFormat</span> <span class="o">=</span>
        <span class="s">&quot;% 4d: f:% 8e d:% 3.2e g:% 3.2e h:% 3.2e &quot;</span>
        <span class="s">&quot;rho:% 3.2e mu:% 3.2e eta:% 3.2e li:% 3d&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="n">StringPrintf</span><span class="p">(</span><span class="n">kReportRowFormat</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">iteration</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">cost</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">cost_change</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">gradient_max_norm</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">step_norm</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">relative_decrease</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">trust_region_radius</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">eta</span><span class="p">,</span>
                                 <span class="n">summary</span><span class="p">.</span><span class="n">linear_solver_iterations</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">log_to_stdout_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">VLOG</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">SOLVER_CONTINUE</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="k">const</span> <span class="kt">bool</span> <span class="n">log_to_stdout_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="crsmatrix">
<h3><a class="reference internal" href="#CRSMatrix" title="CRSMatrix"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CRSMatrix</span></tt></a><a class="headerlink" href="#crsmatrix" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="CRSMatrix">
<em class="property">class </em><tt class="descname">CRSMatrix</tt><a class="headerlink" href="#CRSMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A compressed row sparse matrix used primarily for communicating the
Jacobian matrix to the user.</p>
</dd></dl>

<dl class="member">
<dt id="CRSMatrix::num_rows__i">
int <tt class="descclassname">CRSMatrix::</tt><tt class="descname">num_rows</tt><a class="headerlink" href="#CRSMatrix::num_rows__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of rows.</p>
</dd></dl>

<dl class="member">
<dt id="CRSMatrix::num_cols__i">
int <tt class="descclassname">CRSMatrix::</tt><tt class="descname">num_cols</tt><a class="headerlink" href="#CRSMatrix::num_cols__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of columns.</p>
</dd></dl>

<dl class="member">
<dt id="CRSMatrix::rows__vector:i:">
vector&lt;int&gt; <tt class="descclassname">CRSMatrix::</tt><tt class="descname">rows</tt><a class="headerlink" href="#CRSMatrix::rows__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#CRSMatrix::rows__vector:i:" title="CRSMatrix::rows"><tt class="xref cpp cpp-member docutils literal"><span class="pre">CRSMatrix::rows</span></tt></a> is a <a class="reference internal" href="#CRSMatrix::num_rows__i" title="CRSMatrix::num_rows"><tt class="xref cpp cpp-member docutils literal"><span class="pre">CRSMatrix::num_rows</span></tt></a> + 1
sized array that points into the <a class="reference internal" href="#CRSMatrix::cols__vector:i:" title="CRSMatrix::cols"><tt class="xref cpp cpp-member docutils literal"><span class="pre">CRSMatrix::cols</span></tt></a> and
<a class="reference internal" href="#CRSMatrix::values__vector:i:" title="CRSMatrix::values"><tt class="xref cpp cpp-member docutils literal"><span class="pre">CRSMatrix::values</span></tt></a> array.</p>
</dd></dl>

<dl class="member">
<dt id="CRSMatrix::cols__vector:i:">
vector&lt;int&gt; <tt class="descclassname">CRSMatrix::</tt><tt class="descname">cols</tt><a class="headerlink" href="#CRSMatrix::cols__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#CRSMatrix::cols__vector:i:" title="CRSMatrix::cols"><tt class="xref cpp cpp-member docutils literal"><span class="pre">CRSMatrix::cols</span></tt></a> contain as many entries as there are
non-zeros in the matrix.</p>
<p>For each row <tt class="docutils literal"><span class="pre">i</span></tt>, <tt class="docutils literal"><span class="pre">cols[rows[i]]</span></tt> ... <tt class="docutils literal"><span class="pre">cols[rows[i</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">1]</span></tt>
are the indices of the non-zero columns of row <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="CRSMatrix::values__vector:i:">
vector&lt;int&gt; <tt class="descclassname">CRSMatrix::</tt><tt class="descname">values</tt><a class="headerlink" href="#CRSMatrix::values__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#CRSMatrix::values__vector:i:" title="CRSMatrix::values"><tt class="xref cpp cpp-member docutils literal"><span class="pre">CRSMatrix::values</span></tt></a> contain as many entries as there are
non-zeros in the matrix.</p>
<p>For each row <tt class="docutils literal"><span class="pre">i</span></tt>,
<tt class="docutils literal"><span class="pre">values[rows[i]]</span></tt> ... <tt class="docutils literal"><span class="pre">values[rows[i</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">1]</span></tt> are the values
of the non-zero columns of row <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</dd></dl>

<p>e.g, consider the 3x4 sparse matrix</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="mi">0</span> <span class="mi">10</span>  <span class="mi">0</span>  <span class="mi">4</span>
<span class="mi">0</span>  <span class="mi">2</span> <span class="o">-</span><span class="mi">3</span>  <span class="mi">2</span>
<span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">0</span>  <span class="mi">0</span>
</pre></div>
</div>
<p>The three arrays will be:</p>
<div class="highlight-c++"><div class="highlight"><pre>         <span class="o">-</span><span class="n">row0</span><span class="o">-</span>  <span class="o">---</span><span class="n">row1</span><span class="o">---</span>  <span class="o">-</span><span class="n">row2</span><span class="o">-</span>
<span class="n">rows</span>   <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>      <span class="mi">2</span><span class="p">,</span>          <span class="mi">5</span><span class="p">,</span>     <span class="mi">7</span><span class="p">]</span>
<span class="n">cols</span>   <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="solver-summary">
<h3><a class="reference internal" href="#Solver::Summary" title="Solver::Summary"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Solver::Summary</span></tt></a><a class="headerlink" href="#solver-summary" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="Solver::Summary">
<em class="property">class </em><tt class="descclassname">Solver::</tt><tt class="descname">Summary</tt><a class="headerlink" href="#Solver::Summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Summary of the various stages of the solver after termination.</p>
</dd></dl>

<dl class="function">
<dt id="Solver::Summary::BriefReportC">
string <tt class="descclassname">Solver::Summary::</tt><tt class="descname">BriefReport</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Solver::Summary::BriefReportC" title="Permalink to this definition">¶</a></dt>
<dd><p>A brief one line description of the state of the solver after
termination.</p>
</dd></dl>

<dl class="function">
<dt id="Solver::Summary::FullReportC">
string <tt class="descclassname">Solver::Summary::</tt><tt class="descname">FullReport</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Solver::Summary::FullReportC" title="Permalink to this definition">¶</a></dt>
<dd><p>A full multiline description of the state of the solver after
termination.</p>
</dd></dl>

<dl class="function">
<dt id="Solver::Summary::IsSolutionUsableC">
bool <tt class="descclassname">Solver::Summary::</tt><tt class="descname">IsSolutionUsable</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Solver::Summary::IsSolutionUsableC" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the solution returned by the optimization algorithm can be
relied on to be numerically sane. This will be the case if
<cite>Solver::Summary:termination_type</cite> is set to <cite>CONVERGENCE</cite>,
<cite>USER_SUCCESS</cite> or <cite>NO_CONVERGENCE</cite>, i.e., either the solver
converged by meeting one of the convergence tolerances or because
the user indicated that it had converged or it ran to the maximum
number of iterations or time.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::minimizer_type__MinimizerType">
MinimizerType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">minimizer_type</tt><a class="headerlink" href="#Solver::Summary::minimizer_type__MinimizerType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of minimization algorithm used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::termination_type__TerminationType">
TerminationType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">termination_type</tt><a class="headerlink" href="#Solver::Summary::termination_type__TerminationType" title="Permalink to this definition">¶</a></dt>
<dd><p>The cause of the minimizer terminating.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::message__string">
string <tt class="descclassname">Solver::Summary::</tt><tt class="descname">message</tt><a class="headerlink" href="#Solver::Summary::message__string" title="Permalink to this definition">¶</a></dt>
<dd><p>Reason why the solver terminated.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::initial_cost__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">initial_cost</tt><a class="headerlink" href="#Solver::Summary::initial_cost__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Cost of the problem (value of the objective function) before the
optimization.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::final_cost__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">final_cost</tt><a class="headerlink" href="#Solver::Summary::final_cost__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Cost of the problem (value of the objective function) after the
optimization.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::fixed_cost__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">fixed_cost</tt><a class="headerlink" href="#Solver::Summary::fixed_cost__double" title="Permalink to this definition">¶</a></dt>
<dd><p>The part of the total cost that comes from residual blocks that
were held fixed by the preprocessor because all the parameter
blocks that they depend on were fixed.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::iterations__vector:IterationSummary:">
vector&lt;IterationSummary&gt; <tt class="descclassname">Solver::Summary::</tt><tt class="descname">iterations</tt><a class="headerlink" href="#Solver::Summary::iterations__vector:IterationSummary:" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#IterationSummary" title="IterationSummary"><tt class="xref cpp cpp-class docutils literal"><span class="pre">IterationSummary</span></tt></a> for each minimizer iteration in order.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_successful_steps__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_successful_steps</tt><a class="headerlink" href="#Solver::Summary::num_successful_steps__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of minimizer iterations in which the step was
accepted. Unless <tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Options::use_non_monotonic_steps</span></tt>
is <cite>true</cite> this is also the number of steps in which the objective
function value/cost went down.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_unsuccessful_steps__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_unsuccessful_steps</tt><a class="headerlink" href="#Solver::Summary::num_unsuccessful_steps__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of minimizer iterations in which the step was rejected
either because it did not reduce the cost enough or the step was
not numerically valid.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_inner_iteration_steps__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_inner_iteration_steps</tt><a class="headerlink" href="#Solver::Summary::num_inner_iteration_steps__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of times inner iterations were performed.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::preprocessor_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">preprocessor_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::preprocessor_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent in the preprocessor.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::minimizer_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">minimizer_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::minimizer_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent in the Minimizer.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::postprocessor_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">postprocessor_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::postprocessor_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent in the post processor.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::total_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">total_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::total_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent in the solver.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::linear_solver_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">linear_solver_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::linear_solver_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent in the linear solver computing the trust
region step.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::residual_evaluation_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">residual_evaluation_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::residual_evaluation_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent evaluating the residual vector.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::jacobian_evaluation_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">jacobian_evaluation_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::jacobian_evaluation_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent evaluating the Jacobian matrix.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::inner_iteration_time_in_seconds__double">
double <tt class="descclassname">Solver::Summary::</tt><tt class="descname">inner_iteration_time_in_seconds</tt><a class="headerlink" href="#Solver::Summary::inner_iteration_time_in_seconds__double" title="Permalink to this definition">¶</a></dt>
<dd><p>Time (in seconds) spent doing inner iterations.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_parameter_blocks__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_parameter_blocks</tt><a class="headerlink" href="#Solver::Summary::num_parameter_blocks__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of parameter blocks in the problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_parameters__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_parameters</tt><a class="headerlink" href="#Solver::Summary::num_parameters__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of parameters in the problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_effective_parameters__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_effective_parameters</tt><a class="headerlink" href="#Solver::Summary::num_effective_parameters__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the tangent space of the problem (or the number of
columns in the Jacobian for the problem). This is different from
<a class="reference internal" href="#Solver::Summary::num_parameters__i" title="Solver::Summary::num_parameters"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::num_parameters</span></tt></a> if a parameter block is
associated with a <a class="reference internal" href="modeling.html#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_residual_blocks__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_residual_blocks</tt><a class="headerlink" href="#Solver::Summary::num_residual_blocks__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of residual blocks in the problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_residuals__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_residuals</tt><a class="headerlink" href="#Solver::Summary::num_residuals__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of residuals in the problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_parameter_blocks_reduced__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_parameter_blocks_reduced</tt><a class="headerlink" href="#Solver::Summary::num_parameter_blocks_reduced__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of parameter blocks in the problem after the inactive and
constant parameter blocks have been removed. A parameter block is
inactive if no residual block refers to it.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_parameters_reduced__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_parameters_reduced</tt><a class="headerlink" href="#Solver::Summary::num_parameters_reduced__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of parameters in the reduced problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_effective_parameters_reduced__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_effective_parameters_reduced</tt><a class="headerlink" href="#Solver::Summary::num_effective_parameters_reduced__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the tangent space of the reduced problem (or the
number of columns in the Jacobian for the reduced problem). This is
different from <a class="reference internal" href="#Solver::Summary::num_parameters_reduced__i" title="Solver::Summary::num_parameters_reduced"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::num_parameters_reduced</span></tt></a> if
a parameter block in the reduced problem is associated with a
<a class="reference internal" href="modeling.html#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_residual_blocks_reduced__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_residual_blocks_reduced</tt><a class="headerlink" href="#Solver::Summary::num_residual_blocks_reduced__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of residual blocks in the reduced problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_residuals_reduced__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_residuals_reduced</tt><a class="headerlink" href="#Solver::Summary::num_residuals_reduced__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of residuals in the reduced problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_threads_given__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_threads_given</tt><a class="headerlink" href="#Solver::Summary::num_threads_given__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of threads specified by the user for Jacobian and residual
evaluation.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_threads_used__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_threads_used</tt><a class="headerlink" href="#Solver::Summary::num_threads_used__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of threads actually used by the solver for Jacobian and
residual evaluation. This number is not equal to
<a class="reference internal" href="#Solver::Summary::num_threads_given__i" title="Solver::Summary::num_threads_given"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::num_threads_given</span></tt></a> if <cite>OpenMP</cite> is not
available.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_linear_solver_threads_given__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_linear_solver_threads_given</tt><a class="headerlink" href="#Solver::Summary::num_linear_solver_threads_given__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of threads specified by the user for solving the trust
region problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::num_linear_solver_threads_used__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">num_linear_solver_threads_used</tt><a class="headerlink" href="#Solver::Summary::num_linear_solver_threads_used__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of threads actually used by the solver for solving the trust
region problem. This number is not equal to
<a class="reference internal" href="#Solver::Summary::num_linear_solver_threads_given__i" title="Solver::Summary::num_linear_solver_threads_given"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::num_linear_solver_threads_given</span></tt></a> if
<cite>OpenMP</cite> is not available.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::linear_solver_type_given__LinearSolverType">
LinearSolverType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">linear_solver_type_given</tt><a class="headerlink" href="#Solver::Summary::linear_solver_type_given__LinearSolverType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the linear solver requested by the user.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::linear_solver_type_used__LinearSolverType">
LinearSolverType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">linear_solver_type_used</tt><a class="headerlink" href="#Solver::Summary::linear_solver_type_used__LinearSolverType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the linear solver actually used. This may be different from
<a class="reference internal" href="#Solver::Summary::linear_solver_type_given__LinearSolverType" title="Solver::Summary::linear_solver_type_given"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::linear_solver_type_given</span></tt></a> if Ceres
determines that the problem structure is not compatible with the
linear solver requested or if the linear solver requested by the
user is not available, e.g. The user requested
<cite>SPARSE_NORMAL_CHOLESKY</cite> but no sparse linear algebra library was
available.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::linear_solver_ordering_given__vector:i:">
vector&lt;int&gt; <tt class="descclassname">Solver::Summary::</tt><tt class="descname">linear_solver_ordering_given</tt><a class="headerlink" href="#Solver::Summary::linear_solver_ordering_given__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the elimination groups given by the user as hints to the
linear solver.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::linear_solver_ordering_used__vector:i:">
vector&lt;int&gt; <tt class="descclassname">Solver::Summary::</tt><tt class="descname">linear_solver_ordering_used</tt><a class="headerlink" href="#Solver::Summary::linear_solver_ordering_used__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the parameter groups used by the solver when ordering the
columns of the Jacobian.  This maybe different from
<a class="reference internal" href="#Solver::Summary::linear_solver_ordering_given__vector:i:" title="Solver::Summary::linear_solver_ordering_given"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::linear_solver_ordering_given</span></tt></a> if the user
left <a class="reference internal" href="#Solver::Summary::linear_solver_ordering_given__vector:i:" title="Solver::Summary::linear_solver_ordering_given"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::linear_solver_ordering_given</span></tt></a> blank
and asked for an automatic ordering, or if the problem contains
some constant or inactive parameter blocks.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::inner_iterations_given__b">
bool <tt class="descclassname">Solver::Summary::</tt><tt class="descname">inner_iterations_given</tt><a class="headerlink" href="#Solver::Summary::inner_iterations_given__b" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> if the user asked for inner iterations to be used as part of
the optimization.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::inner_iterations_used__b">
bool <tt class="descclassname">Solver::Summary::</tt><tt class="descname">inner_iterations_used</tt><a class="headerlink" href="#Solver::Summary::inner_iterations_used__b" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> if the user asked for inner iterations to be used as part of
the optimization and the problem structure was such that they were
actually performed. e.g., in a problem with just one parameter
block, inner iterations are not performed.</p>
</dd></dl>

<dl class="member">
<dt id="inner_iteration_ordering_given__vector:i:">
vector&lt;int&gt; <tt class="descname">inner_iteration_ordering_given</tt><a class="headerlink" href="#inner_iteration_ordering_given__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the parameter groups given by the user for performing inner
iterations.</p>
</dd></dl>

<dl class="member">
<dt id="inner_iteration_ordering_used__vector:i:">
vector&lt;int&gt; <tt class="descname">inner_iteration_ordering_used</tt><a class="headerlink" href="#inner_iteration_ordering_used__vector:i:" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the parameter groups given used by the solver for
performing inner iterations. This maybe different from
<tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::inner_iteration_ordering_given</span></tt> if the
user left <tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::inner_iteration_ordering_given</span></tt>
blank and asked for an automatic ordering, or if the problem
contains some constant or inactive parameter blocks.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::preconditioner_type__PreconditionerType">
PreconditionerType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">preconditioner_type</tt><a class="headerlink" href="#Solver::Summary::preconditioner_type__PreconditionerType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of preconditioner used for solving the trust region step. Only
meaningful when an iterative linear solver is used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::visibility_clustering_type__VisibilityClusteringType">
VisibilityClusteringType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">visibility_clustering_type</tt><a class="headerlink" href="#Solver::Summary::visibility_clustering_type__VisibilityClusteringType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of clustering algorithm used for visibility based
preconditioning. Only meaningful when the
<a class="reference internal" href="#Solver::Summary::preconditioner_type__PreconditionerType" title="Solver::Summary::preconditioner_type"><tt class="xref cpp cpp-member docutils literal"><span class="pre">Solver::Summary::preconditioner_type</span></tt></a> is
<tt class="docutils literal"><span class="pre">CLUSTER_JACOBI</span></tt> or <tt class="docutils literal"><span class="pre">CLUSTER_TRIDIAGONAL</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::trust_region_strategy_type__TrustRegionStrategyType">
TrustRegionStrategyType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">trust_region_strategy_type</tt><a class="headerlink" href="#Solver::Summary::trust_region_strategy_type__TrustRegionStrategyType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of trust region strategy.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::dogleg_type__DoglegType">
DoglegType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">dogleg_type</tt><a class="headerlink" href="#Solver::Summary::dogleg_type__DoglegType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of dogleg strategy used for solving the trust region problem.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::dense_linear_algebra_library_type__DenseLinearAlgebraLibraryType">
DenseLinearAlgebraLibraryType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">dense_linear_algebra_library_type</tt><a class="headerlink" href="#Solver::Summary::dense_linear_algebra_library_type__DenseLinearAlgebraLibraryType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the dense linear algebra library used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::sparse_linear_algebra_library_type__SparseLinearAlgebraLibraryType">
SparseLinearAlgebraLibraryType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">sparse_linear_algebra_library_type</tt><a class="headerlink" href="#Solver::Summary::sparse_linear_algebra_library_type__SparseLinearAlgebraLibraryType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the sparse linear algebra library used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::line_search_direction_type__LineSearchDirectionType">
LineSearchDirectionType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">line_search_direction_type</tt><a class="headerlink" href="#Solver::Summary::line_search_direction_type__LineSearchDirectionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of line search direction used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::line_search_type__LineSearchType">
LineSearchType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">line_search_type</tt><a class="headerlink" href="#Solver::Summary::line_search_type__LineSearchType" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the line search algorithm used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::line_search_interpolation_type__LineSearchInterpolationType">
LineSearchInterpolationType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">line_search_interpolation_type</tt><a class="headerlink" href="#Solver::Summary::line_search_interpolation_type__LineSearchInterpolationType" title="Permalink to this definition">¶</a></dt>
<dd><p>When performing line search, the degree of the polynomial used to
approximate the objective function.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::nonlinear_conjugate_gradient_type__NonlinearConjugateGradientType">
NonlinearConjugateGradientType <tt class="descclassname">Solver::Summary::</tt><tt class="descname">nonlinear_conjugate_gradient_type</tt><a class="headerlink" href="#Solver::Summary::nonlinear_conjugate_gradient_type__NonlinearConjugateGradientType" title="Permalink to this definition">¶</a></dt>
<dd><p>If the line search direction is <cite>NONLINEAR_CONJUGATE_GRADIENT</cite>,
then this indicates the particular variant of non-linear conjugate
gradient used.</p>
</dd></dl>

<dl class="member">
<dt id="Solver::Summary::max_lbfgs_rank__i">
int <tt class="descclassname">Solver::Summary::</tt><tt class="descname">max_lbfgs_rank</tt><a class="headerlink" href="#Solver::Summary::max_lbfgs_rank__i" title="Permalink to this definition">¶</a></dt>
<dd><p>If the type of the line search direction is <cite>LBFGS</cite>, then this
indicates the rank of the Hessian approximation.</p>
</dd></dl>

</div>
</div>
<div class="section" id="covariance-estimation">
<h2>Covariance Estimation<a class="headerlink" href="#covariance-estimation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>One way to assess the quality of the solution returned by a
non-linear least squares solve is to analyze the covariance of the
solution.</p>
<p>Let us consider the non-linear regression problem</p>
<div class="math">
\[y = f(x) + N(0, I)\]</div>
<p>i.e., the observation <span class="math">\(y\)</span> is a random non-linear function of the
independent variable <span class="math">\(x\)</span> with mean <span class="math">\(f(x)\)</span> and identity
covariance. Then the maximum likelihood estimate of <span class="math">\(x\)</span> given
observations <span class="math">\(y\)</span> is the solution to the non-linear least squares
problem:</p>
<div class="math">
\[x^* = \arg \min_x \|f(x)\|^2\]</div>
<p>And the covariance of <span class="math">\(x^*\)</span> is given by</p>
<div class="math">
\[C(x^*) = \left(J'(x^*)J(x^*)\right)^{-1}\]</div>
<p>Here <span class="math">\(J(x^*)\)</span> is the Jacobian of <span class="math">\(f\)</span> at <span class="math">\(x^*\)</span>. The
above formula assumes that <span class="math">\(J(x^*)\)</span> has full column rank.</p>
<p>If <span class="math">\(J(x^*)\)</span> is rank deficient, then the covariance matrix <span class="math">\(C(x^*)\)</span>
is also rank deficient and is given by the Moore-Penrose pseudo inverse.</p>
<div class="math">
\[C(x^*) =  \left(J'(x^*)J(x^*)\right)^{\dagger}\]</div>
<p>Note that in the above, we assumed that the covariance matrix for
<span class="math">\(y\)</span> was identity. This is an important assumption. If this is
not the case and we have</p>
<div class="math">
\[y = f(x) + N(0, S)\]</div>
<p>Where <span class="math">\(S\)</span> is a positive semi-definite matrix denoting the
covariance of <span class="math">\(y\)</span>, then the maximum likelihood problem to be
solved is</p>
<div class="math">
\[x^* = \arg \min_x f'(x) S^{-1} f(x)\]</div>
<p>and the corresponding covariance estimate of <span class="math">\(x^*\)</span> is given by</p>
<div class="math">
\[C(x^*) = \left(J'(x^*) S^{-1} J(x^*)\right)^{-1}\]</div>
<p>So, if it is the case that the observations being fitted to have a
covariance matrix not equal to identity, then it is the user&#8217;s
responsibility that the corresponding cost functions are correctly
scaled, e.g. in the above case the cost function for this problem
should evaluate <span class="math">\(S^{-1/2} f(x)\)</span> instead of just <span class="math">\(f(x)\)</span>,
where <span class="math">\(S^{-1/2}\)</span> is the inverse square root of the covariance
matrix <span class="math">\(S\)</span>.</p>
</div>
<div class="section" id="gauge-invariance">
<h3>Gauge Invariance<a class="headerlink" href="#gauge-invariance" title="Permalink to this headline">¶</a></h3>
<p>In structure from motion (3D reconstruction) problems, the
reconstruction is ambiguous upto a similarity transform. This is
known as a <em>Gauge Ambiguity</em>. Handling Gauges correctly requires the
use of SVD or custom inversion algorithms. For small problems the
user can use the dense algorithm. For more details see the work of
Kanatani &amp; Morris <a class="reference internal" href="bibliography.html#kanatanimorris" id="id39">[KanataniMorris]</a>.</p>
</div>
<div class="section" id="covariance">
<h3><a class="reference internal" href="#Covariance" title="Covariance"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance</span></tt></a><a class="headerlink" href="#covariance" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#Covariance" title="Covariance"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance</span></tt></a> allows the user to evaluate the covariance for a
non-linear least squares problem and provides random access to its
blocks. The computation assumes that the cost functions compute
residuals such that their covariance is identity.</p>
<p>Since the computation of the covariance matrix requires computing the
inverse of a potentially large matrix, this can involve a rather large
amount of time and memory. However, it is usually the case that the
user is only interested in a small part of the covariance
matrix. Quite often just the block diagonal. <a class="reference internal" href="#Covariance" title="Covariance"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance</span></tt></a>
allows the user to specify the parts of the covariance matrix that she
is interested in and then uses this information to only compute and
store those parts of the covariance matrix.</p>
</div>
<div class="section" id="rank-of-the-jacobian">
<h3>Rank of the Jacobian<a class="headerlink" href="#rank-of-the-jacobian" title="Permalink to this headline">¶</a></h3>
<p>As we noted above, if the Jacobian is rank deficient, then the inverse
of <span class="math">\(J'J\)</span> is not defined and instead a pseudo inverse needs to be
computed.</p>
<p>The rank deficiency in <span class="math">\(J\)</span> can be <em>structural</em> &#8211; columns
which are always known to be zero or <em>numerical</em> &#8211; depending on the
exact values in the Jacobian.</p>
<p>Structural rank deficiency occurs when the problem contains parameter
blocks that are constant. This class correctly handles structural rank
deficiency like that.</p>
<p>Numerical rank deficiency, where the rank of the matrix cannot be
predicted by its sparsity structure and requires looking at its
numerical values is more complicated. Here again there are two
cases.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>The rank deficiency arises from overparameterization. e.g., a
four dimensional quaternion used to parameterize <span class="math">\(SO(3)\)</span>,
which is a three dimensional manifold. In cases like this, the
user should use an appropriate
<a class="reference internal" href="modeling.html#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a>. Not only will this lead to better
numerical behaviour of the Solver, it will also expose the rank
deficiency to the <a class="reference internal" href="#Covariance" title="Covariance"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance</span></tt></a> object so that it can
handle it correctly.</li>
<li>More general numerical rank deficiency in the Jacobian requires
the computation of the so called Singular Value Decomposition
(SVD) of <span class="math">\(J'J\)</span>. We do not know how to do this for large
sparse matrices efficiently. For small and moderate sized
problems this is done using dense linear algebra.</li>
</ol>
</div></blockquote>
<p><a class="reference internal" href="#Covariance::Options" title="Covariance::Options"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance::Options</span></tt></a></p>
<dl class="class">
<dt id="Covariance::Options">
<em class="property">class </em><tt class="descclassname">Covariance::</tt><tt class="descname">Options</tt><a class="headerlink" href="#Covariance::Options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="Covariance::Options::num_threads__i">
int <tt class="descclassname">Covariance::Options::</tt><tt class="descname">num_threads</tt><a class="headerlink" href="#Covariance::Options::num_threads__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">1</span></tt></p>
<p>Number of threads to be used for evaluating the Jacobian and
estimation of covariance.</p>
</dd></dl>

<dl class="member">
<dt id="Covariance::Options::algorithm_type__CovarianceAlgorithmType">
CovarianceAlgorithmType <tt class="descclassname">Covariance::Options::</tt><tt class="descname">algorithm_type</tt><a class="headerlink" href="#Covariance::Options::algorithm_type__CovarianceAlgorithmType" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <tt class="docutils literal"><span class="pre">SPARSE_QR</span></tt> or <tt class="docutils literal"><span class="pre">DENSE_SVD</span></tt></p>
<p>Ceres supports three different algorithms for covariance
estimation, which represent different tradeoffs in speed, accuracy
and reliability.</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal"><span class="pre">DENSE_SVD</span></tt> uses <tt class="docutils literal"><span class="pre">Eigen</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">JacobiSVD</span></tt> to perform the
computations. It computes the singular value decomposition</p>
<div class="math">
\[U S V^\top = J\]</div>
<p>and then uses it to compute the pseudo inverse of J&#8217;J as</p>
<div class="math">
\[(J'J)^{\dagger} = V  S^{\dagger}  V^\top\]</div>
<p>It is an accurate but slow method and should only be used for
small to moderate sized problems. It can handle full-rank as
well as rank deficient Jacobians.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">SPARSE_CHOLESKY</span></tt> uses the <tt class="docutils literal"><span class="pre">CHOLMOD</span></tt> sparse Cholesky
factorization library to compute the decomposition :</p>
<div class="math">
\[R^\top R = J^\top J\]</div>
<p>and then</p>
<div class="math">
\[\left(J^\top J\right)^{-1}  = \left(R^\top R\right)^{-1}\]</div>
<p>It a fast algorithm for sparse matrices that should be used when
the Jacobian matrix J is well conditioned. For ill-conditioned
matrices, this algorithm can fail unpredictabily. This is
because Cholesky factorization is not a rank-revealing
factorization, i.e., it cannot reliably detect when the matrix
being factorized is not of full
rank. <tt class="docutils literal"><span class="pre">SuiteSparse</span></tt>/<tt class="docutils literal"><span class="pre">CHOLMOD</span></tt> supplies a heuristic for
checking if the matrix is rank deficient (cholmod_rcond), but it
is only a heuristic and can have both false positive and false
negatives.</p>
<p>Recent versions of <tt class="docutils literal"><span class="pre">SuiteSparse</span></tt> (&gt;= 4.2.0) provide a much more
efficient method for solving for rows of the covariance
matrix. Therefore, if you are doing <tt class="docutils literal"><span class="pre">SPARSE_CHOLESKY</span></tt>, we strongly
recommend using a recent version of <tt class="docutils literal"><span class="pre">SuiteSparse</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">SPARSE_QR</span></tt> uses the <tt class="docutils literal"><span class="pre">SuiteSparseQR</span></tt> sparse QR factorization
library to compute the decomposition</p>
<blockquote>
<div><div class="math">
\[\begin{split}QR &amp;= J\\
\left(J^\top J\right)^{-1} &amp;= \left(R^\top R\right)^{-1}\end{split}\]</div>
</div></blockquote>
<p>It is a moderately fast algorithm for sparse matrices, which at
the price of more time and memory than the <tt class="docutils literal"><span class="pre">SPARSE_CHOLESKY</span></tt>
algorithm is numerically better behaved and is rank revealing,
i.e., it can reliably detect when the Jacobian matrix is rank
deficient.</p>
</li>
</ol>
<p>Neither <tt class="docutils literal"><span class="pre">SPARSE_CHOLESKY</span></tt> or <tt class="docutils literal"><span class="pre">SPARSE_QR</span></tt> are capable of computing
the covariance if the Jacobian is rank deficient.</p>
</dd></dl>

<dl class="member">
<dt id="Covariance::Options::min_reciprocal_condition_number__i">
int <tt class="descclassname">Covariance::Options::</tt><tt class="descname">min_reciprocal_condition_number</tt><a class="headerlink" href="#Covariance::Options::min_reciprocal_condition_number__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <span class="math">\(10^{-14}\)</span></p>
<p>If the Jacobian matrix is near singular, then inverting <span class="math">\(J'J\)</span>
will result in unreliable results, e.g, if</p>
<div class="math">
\[\begin{split}J = \begin{bmatrix}
    1.0&amp; 1.0 \\
    1.0&amp; 1.0000001
    \end{bmatrix}\end{split}\]</div>
<p>which is essentially a rank deficient matrix, we have</p>
<div class="math">
\[\begin{split}(J'J)^{-1} = \begin{bmatrix}
             2.0471e+14&amp;  -2.0471e+14 \\
             -2.0471e+14   2.0471e+14
             \end{bmatrix}\end{split}\]</div>
<p>This is not a useful result. Therefore, by default
<a class="reference internal" href="#Covariance::Compute__vector:pair:doubleCP.doubleCP::CR.ProblemP" title="Covariance::Compute"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Covariance::Compute()</span></tt></a> will return <tt class="docutils literal"><span class="pre">false</span></tt> if a rank
deficient Jacobian is encountered. How rank deficiency is detected
depends on the algorithm being used.</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal"><span class="pre">DENSE_SVD</span></tt></p>
<div class="math">
\[\begin{split}\frac{\sigma_{\text{min}}}{\sigma_{\text{max}}}  &lt; \sqrt{\text{min_reciprocal_condition_number}}\end{split}\]</div>
<p>where <span class="math">\(\sigma_{\text{min}}\)</span> and
<span class="math">\(\sigma_{\text{max}}\)</span> are the minimum and maxiumum
singular values of <span class="math">\(J\)</span> respectively.</p>
</li>
</ol>
<blockquote>
<div><ol class="arabic" start="2">
<li><p class="first"><tt class="docutils literal"><span class="pre">SPARSE_CHOLESKY</span></tt></p>
<div class="math">
\[\begin{split}\text{cholmod_rcond} &lt; \text{min_reciprocal_conditioner_number}\end{split}\]</div>
</li>
</ol>
<blockquote>
<div>Here cholmod_rcond is a crude estimate of the reciprocal
condition number of <span class="math">\(J^\top J\)</span> by using the maximum and
minimum diagonal entries of the Cholesky factor <span class="math">\(R\)</span>. There
are no theoretical guarantees associated with this test. It can
give false positives and negatives. Use at your own risk. The
default value of <tt class="docutils literal"><span class="pre">min_reciprocal_condition_number</span></tt> has been
set to a conservative value, and sometimes the
<a class="reference internal" href="#Covariance::Compute__vector:pair:doubleCP.doubleCP::CR.ProblemP" title="Covariance::Compute"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Covariance::Compute()</span></tt></a> may return false even if it is
possible to estimate the covariance reliably. In such cases, the
user should exercise their judgement before lowering the value
of <tt class="docutils literal"><span class="pre">min_reciprocal_condition_number</span></tt>.</div></blockquote>
<ol class="arabic" start="3">
<li><p class="first"><tt class="docutils literal"><span class="pre">SPARSE_QR</span></tt></p>
<div class="math">
\[\begin{split}\operatorname{rank}(J) &lt; \operatorname{num\_col}(J)\end{split}\]</div>
<p>Here :math:<cite>operatorname{rank}(J)</cite> is the estimate of the
rank of <cite>J</cite> returned by the <tt class="docutils literal"><span class="pre">SuiteSparseQR</span></tt> algorithm. It is
a fairly reliable indication of rank deficiency.</p>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="member">
<dt id="Covariance::Options::null_space_rank__i">
int <tt class="descclassname">Covariance::Options::</tt><tt class="descname">null_space_rank</tt><a class="headerlink" href="#Covariance::Options::null_space_rank__i" title="Permalink to this definition">¶</a></dt>
<dd><p>When using <tt class="docutils literal"><span class="pre">DENSE_SVD</span></tt>, the user has more control in dealing
with singular and near singular covariance matrices.</p>
<p>As mentioned above, when the covariance matrix is near singular,
instead of computing the inverse of <span class="math">\(J'J\)</span>, the Moore-Penrose
pseudoinverse of <span class="math">\(J'J\)</span> should be computed.</p>
<p>If <span class="math">\(J'J\)</span> has the eigen decomposition <span class="math">\((\lambda_i,
e_i)\)</span>, where <span class="math">\(lambda_i\)</span> is the <span class="math">\(i^\textrm{th}\)</span>
eigenvalue and <span class="math">\(e_i\)</span> is the corresponding eigenvector, then
the inverse of <span class="math">\(J'J\)</span> is</p>
<div class="math">
\[(J'J)^{-1} = \sum_i \frac{1}{\lambda_i} e_i e_i'\]</div>
<p>and computing the pseudo inverse involves dropping terms from this
sum that correspond to small eigenvalues.</p>
<p>How terms are dropped is controlled by
<cite>min_reciprocal_condition_number</cite> and <cite>null_space_rank</cite>.</p>
<p>If <cite>null_space_rank</cite> is non-negative, then the smallest
<cite>null_space_rank</cite> eigenvalue/eigenvectors are dropped irrespective
of the magnitude of <span class="math">\(\lambda_i\)</span>. If the ratio of the
smallest non-zero eigenvalue to the largest eigenvalue in the
truncated matrix is still below min_reciprocal_condition_number,
then the <cite>Covariance::Compute()</cite> will fail and return <cite>false</cite>.</p>
<p>Setting <cite>null_space_rank = -1</cite> drops all terms for which</p>
<div class="math">
\[\begin{split}\frac{\lambda_i}{\lambda_{\textrm{max}}} &lt; \textrm{min_reciprocal_condition_number}\end{split}\]</div>
<dl class="docutils">
<dt>This option has no effect on <tt class="docutils literal"><span class="pre">SPARSE_QR</span></tt> and <tt class="docutils literal"><span class="pre">SPARSE_CHOLESKY</span></tt></dt>
<dd>algorithms.</dd>
</dl>
</dd></dl>

<dl class="member">
<dt id="Covariance::Options::apply_loss_function__b">
bool <tt class="descclassname">Covariance::Options::</tt><tt class="descname">apply_loss_function</tt><a class="headerlink" href="#Covariance::Options::apply_loss_function__b" title="Permalink to this definition">¶</a></dt>
<dd><p>Default: <cite>true</cite></p>
<p>Even though the residual blocks in the problem may contain loss
functions, setting <tt class="docutils literal"><span class="pre">apply_loss_function</span></tt> to false will turn off
the application of the loss function to the output of the cost
function and in turn its effect on the covariance.</p>
</dd></dl>

<dl class="class">
<dt id="Covariance">
<em class="property">class </em><tt class="descname">Covariance</tt><a class="headerlink" href="#Covariance" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Covariance::Options" title="Covariance::Options"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance::Options</span></tt></a> as the name implies is used to control
the covariance estimation algorithm. Covariance estimation is a
complicated and numerically sensitive procedure. Please read the
entire documentation for <a class="reference internal" href="#Covariance::Options" title="Covariance::Options"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance::Options</span></tt></a> before using
<a class="reference internal" href="#Covariance" title="Covariance"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="Covariance::Compute__vector:pair:doubleCP.doubleCP::CR.ProblemP">
bool <tt class="descclassname">Covariance::</tt><tt class="descname">Compute</tt><big>(</big>const vector&lt;pair&lt;const double*, const double*&gt;&gt;&amp; <em>covariance_blocks</em>, Problem* <em>problem</em><big>)</big><a class="headerlink" href="#Covariance::Compute__vector:pair:doubleCP.doubleCP::CR.ProblemP" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a part of the covariance matrix.</p>
<p>The vector <tt class="docutils literal"><span class="pre">covariance_blocks</span></tt>, indexes into the covariance
matrix block-wise using pairs of parameter blocks. This allows the
covariance estimation algorithm to only compute and store these
blocks.</p>
<p>Since the covariance matrix is symmetric, if the user passes
<tt class="docutils literal"><span class="pre">&lt;block1,</span> <span class="pre">block2&gt;</span></tt>, then <tt class="docutils literal"><span class="pre">GetCovarianceBlock</span></tt> can be called with
<tt class="docutils literal"><span class="pre">block1</span></tt>, <tt class="docutils literal"><span class="pre">block2</span></tt> as well as <tt class="docutils literal"><span class="pre">block2</span></tt>, <tt class="docutils literal"><span class="pre">block1</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">covariance_blocks</span></tt> cannot contain duplicates. Bad things will
happen if they do.</p>
<p>Note that the list of <tt class="docutils literal"><span class="pre">covariance_blocks</span></tt> is only used to
determine what parts of the covariance matrix are computed. The
full Jacobian is used to do the computation, i.e. they do not have
an impact on what part of the Jacobian is used for computation.</p>
<p>The return value indicates the success or failure of the covariance
computation. Please see the documentation for
<a class="reference internal" href="#Covariance::Options" title="Covariance::Options"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Covariance::Options</span></tt></a> for more on the conditions under which
this function returns <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="GetCovarianceBlock__doubleCP.doubleCP.doublePC">
bool <tt class="descname">GetCovarianceBlock</tt><big>(</big>const double* <em>parameter_block1</em>, const double* <em>parameter_block2</em>, double* <em>covariance_block</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#GetCovarianceBlock__doubleCP.doubleCP.doublePC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the block of the covariance matrix corresponding to
<tt class="docutils literal"><span class="pre">parameter_block1</span></tt> and <tt class="docutils literal"><span class="pre">parameter_block2</span></tt>.</p>
<p>Compute must be called before the first call to <tt class="docutils literal"><span class="pre">GetCovarianceBlock</span></tt>
and the pair <tt class="docutils literal"><span class="pre">&lt;parameter_block1,</span> <span class="pre">parameter_block2&gt;</span></tt> OR the pair
<tt class="docutils literal"><span class="pre">&lt;parameter_block2,</span> <span class="pre">parameter_block1&gt;</span></tt> must have been present in the
vector covariance_blocks when <tt class="docutils literal"><span class="pre">Compute</span></tt> was called. Otherwise
<tt class="docutils literal"><span class="pre">GetCovarianceBlock</span></tt> will return false.</p>
<p><tt class="docutils literal"><span class="pre">covariance_block</span></tt> must point to a memory location that can store
a <tt class="docutils literal"><span class="pre">parameter_block1_size</span> <span class="pre">x</span> <span class="pre">parameter_block2_size</span></tt> matrix. The
returned covariance will be a row-major matrix.</p>
</dd></dl>

</div>
<div class="section" id="example-usage">
<h3>Example Usage<a class="headerlink" href="#example-usage" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">double</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">Build</span> <span class="n">Problem</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">Solve</span> <span class="n">Problem</span><span class="o">&gt;</span>

<span class="n">Covariance</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">Covariance</span> <span class="nf">covariance</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">covariance_blocks</span><span class="p">;</span>
<span class="n">covariance_blocks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>
<span class="n">covariance_blocks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
<span class="n">covariance_blocks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>

<span class="n">CHECK</span><span class="p">(</span><span class="n">covariance</span><span class="p">.</span><span class="n">Compute</span><span class="p">(</span><span class="n">covariance_blocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">));</span>

<span class="kt">double</span> <span class="n">covariance_xx</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">covariance_yy</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">covariance_xy</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
<span class="n">covariance</span><span class="p">.</span><span class="n">GetCovarianceBlock</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">covariance_xx</span><span class="p">)</span>
<span class="n">covariance</span><span class="p">.</span><span class="n">GetCovarianceBlock</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">covariance_yy</span><span class="p">)</span>
<span class="n">covariance</span><span class="p">.</span><span class="n">GetCovarianceBlock</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">covariance_xy</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="faqs.html" class="btn btn-neutral float-right" title="FAQS, Tips &amp; Tricks"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modeling.html" class="btn btn-neutral" title="Modeling"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014 Google Inc.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.9.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
      MathJax.Hub.Config({
          "HTML-CSS": {
            availableFonts: ["TeX"]
          }
        });
      </script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49769510-1', 'ceres-solver.org');
  ga('send', 'pageview');
</script>


</body>
</html>