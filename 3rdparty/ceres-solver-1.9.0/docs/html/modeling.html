

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Modeling &mdash; Ceres Solver</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Ceres Solver" href="index.html"/>
        <link rel="next" title="Solving" href="solving.html"/>
        <link rel="prev" title="Tutorial" href="tutorial.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> Ceres Solver</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">Building &amp; Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="building.html#getting-the-source-code">Getting the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-linux">Building on Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-mac-os-x">Building on Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-windows-with-visual-studio">Building on Windows with Visual Studio</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-android">Building on Android</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building-on-ios">Building on iOS</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#customizing-the-build">Customizing the build</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#using-ceres-with-cmake">Using Ceres with CMake</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#hello-world">Hello World!</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#derivatives">Derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#powell-s-function">Powell&#8217;s Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#curve-fitting">Curve Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#robust-curve-fitting">Robust Curve Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#bundle-adjustment">Bundle Adjustment</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#other-examples">Other Examples</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#costfunction"><tt class="docutils literal"><span class="pre">CostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#sizedcostfunction"><tt class="docutils literal"><span class="pre">SizedCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#autodiffcostfunction"><tt class="docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamicautodiffcostfunction"><tt class="docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#numericdiffcostfunction"><tt class="docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamicnumericdiffcostfunction"><tt class="docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#numericdifffunctor"><tt class="docutils literal"><span class="pre">NumericDiffFunctor</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#costfunctiontofunctor"><tt class="docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#conditionedcostfunction"><tt class="docutils literal"><span class="pre">ConditionedCostFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#normalprior"><tt class="docutils literal"><span class="pre">NormalPrior</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#lossfunction"><tt class="docutils literal"><span class="pre">LossFunction</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#localparameterization"><tt class="docutils literal"><span class="pre">LocalParameterization</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#autodifflocalparameterization"><tt class="docutils literal"><span class="pre">AutoDiffLocalParameterization</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#problem"><tt class="docutils literal"><span class="pre">Problem</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#rotation-h"><tt class="docutils literal"><span class="pre">rotation.h</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solving.html">Solving</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solving.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="solving.html#trust-region-methods">Trust Region Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="solving.html#line-search-methods">Line Search Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="solving.html#linearsolver">LinearSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="solving.html#covariance-estimation">Covariance Estimation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faqs.html">FAQS, Tips &amp; Tricks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#building">Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#modeling">Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#solving">Solving</a></li>
<li class="toctree-l2"><a class="reference internal" href="faqs.html#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#setting-up-your-development-environment">Setting up your Development Environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#submitting-a-change-to-ceres-solver">Submitting a change to Ceres Solver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="version_history.html">Releases</a><ul>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id1">1.9.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id2">1.8.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id5">1.7.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id9">1.6.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id12">1.5.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id16">1.4.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id20">1.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id23">1.2.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id25">1.2.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id27">1.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id30">1.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id33">1.1.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id35">1.1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="version_history.html#id38">1.0.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="history.html#origin-of-the-name">Origin of the name</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Ceres Solver</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          
          <div role="main">
            
  <div class="section" id="modeling">
<span id="chapter-modeling"></span><h1>Modeling<a class="headerlink" href="#modeling" title="Permalink to this headline">¶</a></h1>
<p>Ceres solver consists of two distinct parts. A modeling API which
provides a rich set of tools to construct an optimization problem one
term at a time and a solver API that controls the minimization
algorithm. This chapter is devoted to the task of modeling
optimization problems using Ceres. <a class="reference internal" href="solving.html#chapter-solving"><em>Solving</em></a> discusses
the various ways in which an optimization problem can be solved using
Ceres.</p>
<p>Ceres solves robustified bounds constrained non-linear least squares
problems of the form:</p>
<div class="math" id="equation-ceresproblem">
<span class="eqno">(1)</span>\[\begin{split}\min_{\mathbf{x}} &amp;\quad \frac{1}{2}\sum_{i}
\rho_i\left(\left\|f_i\left(x_{i_1},
... ,x_{i_k}\right)\right\|^2\right)  \\
\text{s.t.} &amp;\quad l_j \le x_j \le u_j\end{split}\]</div>
<p>In Ceres parlance, the expression
<span class="math">\(\rho_i\left(\left\|f_i\left(x_{i_1},...,x_{i_k}\right)\right\|^2\right)\)</span>
is known as a <strong>residual block</strong>, where <span class="math">\(f_i(\cdot)\)</span> is a
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> that depends on the <strong>parameter blocks</strong>
<span class="math">\(\left\{x_{i_1},... , x_{i_k}\right\}\)</span>.</p>
<p>In most optimization problems small groups of scalars occur
together. For example the three components of a translation vector and
the four components of the quaternion that define the pose of a
camera. We refer to such a group of scalars as a <strong>parameter block</strong>. Of
course a parameter block can be just a single scalar too.</p>
<p><span class="math">\(\rho_i\)</span> is a <a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a>. A <a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a> is
a scalar valued function that is used to reduce the influence of
outliers on the solution of non-linear least squares problems.</p>
<p><span class="math">\(l_j\)</span> and <span class="math">\(u_j\)</span> are lower and upper bounds on the
parameter block <span class="math">\(x_j\)</span>.</p>
<p>As a special case, when <span class="math">\(\rho_i(x) = x\)</span>, i.e., the identity
function, and <span class="math">\(l_j = -\infty\)</span> and <span class="math">\(u_j = \infty\)</span> we get
the more familiar unconstrained <a class="reference external" href="http://en.wikipedia.org/wiki/Non-linear_least_squares">non-linear least squares problem</a>.</p>
<div class="math" id="equation-ceresproblemunconstrained">
<span class="eqno">(2)</span>\[\frac{1}{2}\sum_{i} \left\|f_i\left(x_{i_1}, ... ,x_{i_k}\right)\right\|^2.\]</div>
<div class="section" id="costfunction">
<h2><a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a><a class="headerlink" href="#costfunction" title="Permalink to this headline">¶</a></h2>
<p>For each term in the objective function, a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> is
responsible for computing a vector of residuals and if asked a vector
of Jacobian matrices, i.e., given <span class="math">\(\left[x_{i_1}, ... ,
x_{i_k}\right]\)</span>, compute the vector
<span class="math">\(f_i\left(x_{i_1},...,x_{i_k}\right)\)</span> and the matrices</p>
<blockquote>
<div><div class="math">
\[J_{ij} = \frac{\partial}{\partial
x_{i_j}}f_i\left(x_{i_1},...,x_{i_k}\right),\quad \forall j
\in \{1, \ldots, k\}\]</div>
</div></blockquote>
<dl class="class">
<dt id="CostFunction">
<em class="property">class </em><tt class="descname">CostFunction</tt><a class="headerlink" href="#CostFunction" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CostFunction</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;&amp;</span> <span class="n">parameter_block_sizes</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">num_residuals</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

 <span class="nl">protected:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;*</span> <span class="n">mutable_parameter_block_sizes</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">set_num_residuals</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_residuals</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<p>The signature of the <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> (number and sizes of input
parameter blocks and number of outputs) is stored in
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> and
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::num_residuals_</span></tt> respectively. User code
inheriting from this class is expected to set these two members with
the corresponding accessors. This information will be verified by the
<a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> when added with <a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a>.</p>
<dl class="function">
<dt id="CostFunction::Evaluate__doubleCPCP.doubleP.doublePP">
bool <tt class="descclassname">CostFunction::</tt><tt class="descname">Evaluate</tt><big>(</big>double const* const* <em>parameters</em>, double* <em>residuals</em>, double** <em>jacobians</em><big>)</big><a class="headerlink" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the residual vector and the Jacobian matrices.</p>
<p><tt class="docutils literal"><span class="pre">parameters</span></tt> is an array of pointers to arrays containing the
various parameter blocks. <tt class="docutils literal"><span class="pre">parameters</span></tt> has the same number of
elements as <tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> and the
parameter blocks are in the same order as
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">residuals</span></tt> is an array of size <tt class="docutils literal"><span class="pre">num_residuals_</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">jacobians</span></tt> is an array of size
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> containing pointers
to storage for Jacobian matrices corresponding to each parameter
block. The Jacobian matrices are in the same order as
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt>. <tt class="docutils literal"><span class="pre">jacobians[i]</span></tt> is
an array that contains <tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::num_residuals_</span></tt> x
<tt class="xref cpp cpp-member docutils literal"><span class="pre">CostFunction::parameter_block_sizes_</span></tt> <tt class="docutils literal"><span class="pre">[i]</span></tt>
elements. Each Jacobian matrix is stored in row-major order, i.e.,
<tt class="docutils literal"><span class="pre">jacobians[i][r</span> <span class="pre">*</span> <span class="pre">parameter_block_size_[i]</span> <span class="pre">+</span> <span class="pre">c]</span></tt> =
<span class="math">\(\frac{\partial residual[r]}{\partial parameters[i][c]}\)</span></p>
<p>If <tt class="docutils literal"><span class="pre">jacobians</span></tt> is <tt class="docutils literal"><span class="pre">NULL</span></tt>, then no derivatives are returned;
this is the case when computing cost only. If <tt class="docutils literal"><span class="pre">jacobians[i]</span></tt> is
<tt class="docutils literal"><span class="pre">NULL</span></tt>, then the Jacobian matrix corresponding to the
<span class="math">\(i^{\textrm{th}}\)</span> parameter block must not be returned, this
is the case when a parameter block is marked constant.</p>
<p><strong>NOTE</strong> The return value indicates whether the computation of the
residuals and/or jacobians was successful or not.</p>
<p>This can be used to communicate numerical failures in Jacobian
computations for instance.</p>
</dd></dl>

</div>
<div class="section" id="sizedcostfunction">
<h2><a class="reference internal" href="#SizedCostFunction" title="SizedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></tt></a><a class="headerlink" href="#sizedcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SizedCostFunction">
<em class="property">class </em><tt class="descname">SizedCostFunction</tt><a class="headerlink" href="#SizedCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>If the size of the parameter blocks and the size of the residual
vector is known at compile time (this is the common case),
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SizeCostFunction</span></tt> can be used where these values can be
specified as template parameters and the user only needs to
implement <a class="reference internal" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="CostFunction::Evaluate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></tt></a>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">N0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SizedCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="autodiffcostfunction">
<h2><a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a><a class="headerlink" href="#autodiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="AutoDiffCostFunction">
<em class="property">class </em><tt class="descname">AutoDiffCostFunction</tt><a class="headerlink" href="#AutoDiffCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Defining a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> or a <a class="reference internal" href="#SizedCostFunction" title="SizedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SizedCostFunction</span></tt></a>
can be a tedious and error prone especially when computing
derivatives.  To this end Ceres provides <a class="reference external" href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span>
       <span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>  <span class="c1">// Number of residuals, or ceres::DYNAMIC.</span>
       <span class="kt">int</span> <span class="n">N0</span><span class="p">,</span>       <span class="c1">// Number of parameters in block 0.</span>
       <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 1.</span>
       <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 2.</span>
       <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 3.</span>
       <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 4.</span>
       <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 5.</span>
       <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 6.</span>
       <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 7.</span>
       <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 8.</span>
       <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>   <span class="c1">// Number of parameters in block 9.</span>
<span class="k">class</span> <span class="nc">AutoDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span>
<span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="n">kNumResiduals</span><span class="p">,</span> <span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="p">,</span> <span class="n">N5</span><span class="p">,</span> <span class="n">N6</span><span class="p">,</span> <span class="n">N7</span><span class="p">,</span> <span class="n">N8</span><span class="p">,</span> <span class="n">N9</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">AutoDiffCostFunction</span><span class="p">(</span><span class="n">CostFunctor</span><span class="o">*</span> <span class="n">functor</span><span class="p">);</span>
  <span class="c1">// Ignore the template parameter kNumResiduals and use</span>
  <span class="c1">// num_residuals instead.</span>
  <span class="n">AutoDiffCostFunction</span><span class="p">(</span><span class="n">CostFunctor</span><span class="o">*</span> <span class="n">functor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_residuals</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To get an auto differentiated cost function, you must define a
class with a templated <tt class="docutils literal"><span class="pre">operator()</span></tt> (a functor) that computes the
cost function in terms of the template parameter <tt class="docutils literal"><span class="pre">T</span></tt>. The
autodiff framework substitutes appropriate <tt class="docutils literal"><span class="pre">Jet</span></tt> objects for
<tt class="docutils literal"><span class="pre">T</span></tt> in order to compute the derivative when necessary, but this
is hidden, and you should write the function as if <tt class="docutils literal"><span class="pre">T</span></tt> were a
scalar type (e.g. a double-precision floating point number).</p>
<p>The function must write the computed value in the last argument
(the only non-<tt class="docutils literal"><span class="pre">const</span></tt> one) and return true to indicate success.</p>
<p>For example, consider a scalar error <span class="math">\(e = k - x^\top y\)</span>,
where both <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are two-dimensional vector
parameters and <span class="math">\(k\)</span> is a constant. The form of this error,
which is the difference between a constant and an expression, is a
common pattern in least squares problems. For example, the value
<span class="math">\(x^\top y\)</span> might be the model expectation for a series of
measurements, where there is an instance of the cost function for
each measurement <span class="math">\(k\)</span>.</p>
<p>The actual cost added to the total problem is <span class="math">\(e^2\)</span>, or
<span class="math">\((k - x^\top y)^2\)</span>; however, the squaring is implicitly done
by the optimization framework.</p>
<p>To write an auto-differentiable cost function for the above model,
first define the object</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyScalarCostFunctor</span> <span class="p">{</span>
  <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="kt">double</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span> <span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="kt">double</span> <span class="n">k_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the declaration of <tt class="docutils literal"><span class="pre">operator()</span></tt> the input parameters
<tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> come first, and are passed as const pointers to arrays
of <tt class="docutils literal"><span class="pre">T</span></tt>. If there were three input parameters, then the third input
parameter would come after <tt class="docutils literal"><span class="pre">y</span></tt>. The output is always the last
parameter, and is also a pointer to an array. In the example above,
<tt class="docutils literal"><span class="pre">e</span></tt> is a scalar, so only <tt class="docutils literal"><span class="pre">e[0]</span></tt> is set.</p>
<p>Then given this class definition, the auto differentiated cost
function for it can be constructed as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>              <span class="o">^</span>  <span class="o">^</span>  <span class="o">^</span>
                                                    <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">residual</span> <span class="o">------+</span>  <span class="o">|</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">----------------+</span>  <span class="o">|</span>
                        <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">-------------------+</span>
</pre></div>
</div>
<p>In this example, there is usually an instance for each measurement
of <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
<p>In the instantiation above, the template parameters following
<tt class="docutils literal"><span class="pre">MyScalarCostFunction</span></tt>, <tt class="docutils literal"><span class="pre">&lt;1,</span> <span class="pre">2,</span> <span class="pre">2&gt;</span></tt> describe the functor as
computing a 1-dimensional output from two arguments, both
2-dimensional.</p>
<p><a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> also supports cost functions with a
runtime-determined number of residuals. For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">DYNAMIC</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">CostFunctorWithDynamicNumResiduals</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>   <span class="o">^</span>     <span class="o">^</span>  <span class="o">^</span>
        <span class="n">runtime_number_of_residuals</span><span class="p">);</span> <span class="o">&lt;----+</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Actual</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">------+</span>           <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Indicate</span> <span class="n">dynamic</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">--------+</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">------------------------------------+</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">---------------------------------------+</span>
</pre></div>
</div>
<p>The framework can currently accommodate cost functions of up to 10
independent variables, and there is no limit on the dimensionality
of each of them.</p>
<p><strong>WARNING 1</strong> Since the functor will get instantiated with
different types for <tt class="docutils literal"><span class="pre">T</span></tt>, you must convert from other numeric
types to <tt class="docutils literal"><span class="pre">T</span></tt> before mixing computations with other variables
of type <tt class="docutils literal"><span class="pre">T</span></tt>. In the example above, this is seen where instead of
using <tt class="docutils literal"><span class="pre">k_</span></tt> directly, <tt class="docutils literal"><span class="pre">k_</span></tt> is wrapped with <tt class="docutils literal"><span class="pre">T(k_)</span></tt>.</p>
<p><strong>WARNING 2</strong> A common beginner&#8217;s error when first using
<a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> is to get the sizing wrong. In particular,
there is a tendency to set the template parameters to (dimension of
residual, number of parameters) instead of passing a dimension
parameter for <em>every parameter block</em>. In the example above, that
would be <tt class="docutils literal"><span class="pre">&lt;MyScalarCostFunction,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></tt>, which is missing the 2
as the last template argument.</p>
</dd></dl>

</div>
<div class="section" id="dynamicautodiffcostfunction">
<h2><a class="reference internal" href="#DynamicAutoDiffCostFunction" title="DynamicAutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></tt></a><a class="headerlink" href="#dynamicautodiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="DynamicAutoDiffCostFunction">
<em class="property">class </em><tt class="descname">DynamicAutoDiffCostFunction</tt><a class="headerlink" href="#DynamicAutoDiffCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> requires that the number of parameter
blocks and their sizes be known at compile time. It also has an
upper limit of 10 parameter blocks. In a number of applications,
this is not enough e.g., Bezier curve fitting, Neural Network
training etc.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Stride</span> <span class="o">=</span> <span class="mi">4</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DynamicAutoDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>In such cases <a class="reference internal" href="#DynamicAutoDiffCostFunction" title="DynamicAutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></tt></a> can be
used. Like <a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> the user must define a
templated functor, but the signature of the functor differs
slightly. The expected interface for the cost functors is:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">MyCostFunctor</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Since the sizing of the parameters is done at runtime, you must
also specify the sizes after creating the dynamic autodiff cost
function. For example:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">DynamicAutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunctor</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">cost_function</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">MyCostFunctor</span><span class="p">());</span>
<span class="n">cost_function</span><span class="p">.</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">cost_function</span><span class="p">.</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">cost_function</span><span class="p">.</span><span class="n">SetNumResiduals</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Under the hood, the implementation evaluates the cost function
multiple times, computing a small set of the derivatives (four by
default, controlled by the <tt class="docutils literal"><span class="pre">Stride</span></tt> template parameter) with each
pass. There is a performance tradeoff with the size of the passes;
Smaller sizes are more cache efficient but result in larger number
of passes, and larger stride lengths can destroy cache-locality
while reducing the number of passes over the cost function. The
optimal value depends on the number and sizes of the various
parameter blocks.</p>
<p>As a rule of thumb, try using <a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> before
you use <a class="reference internal" href="#DynamicAutoDiffCostFunction" title="DynamicAutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">DynamicAutoDiffCostFunction</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="numericdiffcostfunction">
<h2><a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a><a class="headerlink" href="#numericdiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NumericDiffCostFunction">
<em class="property">class </em><tt class="descname">NumericDiffCostFunction</tt><a class="headerlink" href="#NumericDiffCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>In some cases, its not possible to define a templated cost functor,
for example when the evaluation of the residual involves a call to a
library function that you do not have control over.  In such a
situation, <a class="reference external" href="http://en.wikipedia.org/wiki/Numerical_differentiation">numerical differentiation</a> can be
used.</p>
<blockquote>
<div><blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span>
          <span class="n">NumericDiffMethod</span> <span class="n">method</span> <span class="o">=</span> <span class="n">CENTRAL</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">kNumResiduals</span><span class="p">,</span>  <span class="c1">// Number of residuals, or ceres::DYNAMIC.</span>
          <span class="kt">int</span> <span class="n">N0</span><span class="p">,</span>       <span class="c1">// Number of parameters in block 0.</span>
          <span class="kt">int</span> <span class="n">N1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 1.</span>
          <span class="kt">int</span> <span class="n">N2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 2.</span>
          <span class="kt">int</span> <span class="n">N3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 3.</span>
          <span class="kt">int</span> <span class="n">N4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 4.</span>
          <span class="kt">int</span> <span class="n">N5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 5.</span>
          <span class="kt">int</span> <span class="n">N6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 6.</span>
          <span class="kt">int</span> <span class="n">N7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 7.</span>
          <span class="kt">int</span> <span class="n">N8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// Number of parameters in block 8.</span>
          <span class="kt">int</span> <span class="n">N9</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>   <span class="c1">// Number of parameters in block 9.</span>
<span class="k">class</span> <span class="nc">NumericDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span>
<span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="n">kNumResiduals</span><span class="p">,</span> <span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="p">,</span> <span class="n">N5</span><span class="p">,</span> <span class="n">N6</span><span class="p">,</span> <span class="n">N7</span><span class="p">,</span> <span class="n">N8</span><span class="p">,</span> <span class="n">N9</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>To get a numerically differentiated <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a>, you must
define a class with a <tt class="docutils literal"><span class="pre">operator()</span></tt> (a functor) that computes the
residuals. The functor must write the computed value in the last
argument (the only non-<tt class="docutils literal"><span class="pre">const</span></tt> one) and return <tt class="docutils literal"><span class="pre">true</span></tt> to
indicate success.  Please see <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> for details on
how the return value may be used to impose simple constraints on
the parameter block. e.g., an object of the form</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">ScalarFunctor</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x1</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x2</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, consider a scalar error <span class="math">\(e = k - x'y\)</span>, where
both <span class="math">\(x\)</span> and <span class="math">\(y\)</span> are two-dimensional column vector
parameters, the prime sign indicates transposition, and <span class="math">\(k\)</span>
is a constant. The form of this error, which is the difference
between a constant and an expression, is a common pattern in least
squares problems. For example, the value <span class="math">\(x'y\)</span> might be the
model expectation for a series of measurements, where there is an
instance of the cost function for each measurement <span class="math">\(k\)</span>.</p>
<p>To write an numerically-differentiable class:<cite>CostFunction</cite> for the
above model, first define the object</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyScalarCostFunctor</span> <span class="p">{</span>
  <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="kt">double</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span> <span class="n">k_</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">y</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="kt">double</span> <span class="n">k_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the declaration of <tt class="docutils literal"><span class="pre">operator()</span></tt> the input parameters
<tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> come first, and are passed as const pointers to
arrays of <tt class="docutils literal"><span class="pre">double</span></tt> s. If there were three input parameters, then
the third input parameter would come after <tt class="docutils literal"><span class="pre">y</span></tt>. The output is
always the last parameter, and is also a pointer to an array. In
the example above, the residual is a scalar, so only
<tt class="docutils literal"><span class="pre">residuals[0]</span></tt> is set.</p>
<p>Then given this class definition, the numerically differentiated
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> with central differences used for computing
the derivative can be constructed as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyScalarCostFunctor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>                    <span class="o">^</span>     <span class="o">^</span>  <span class="o">^</span>  <span class="o">^</span>
                                                          <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                              <span class="n">Finite</span> <span class="n">Differencing</span> <span class="n">Scheme</span> <span class="o">-+</span>     <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>
                              <span class="n">Dimension</span> <span class="n">of</span> <span class="n">residual</span> <span class="o">------------+</span>  <span class="o">|</span>  <span class="o">|</span>
                              <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">----------------------+</span>  <span class="o">|</span>
                              <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">-------------------------+</span>
</pre></div>
</div>
<p>In this example, there is usually an instance for each measurement
of <cite>k</cite>.</p>
<p>In the instantiation above, the template parameters following
<tt class="docutils literal"><span class="pre">MyScalarCostFunctor</span></tt>, <tt class="docutils literal"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2</span></tt>, describe the functor as
computing a 1-dimensional output from two arguments, both
2-dimensional.</p>
<p>NumericDiffCostFunction also supports cost functions with a
runtime-determined number of residuals. For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyScalarCostFunctor</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="n">DYNAMIC</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">CostFunctorWithDynamicNumResiduals</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>               <span class="o">^</span>     <span class="o">^</span>  <span class="o">^</span>
        <span class="n">TAKE_OWNERSHIP</span><span class="p">,</span>                                            <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
        <span class="n">runtime_number_of_residuals</span><span class="p">);</span> <span class="o">&lt;----+</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
                                           <span class="o">|</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Actual</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">------+</span>                       <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Indicate</span> <span class="n">dynamic</span> <span class="n">number</span> <span class="n">of</span> <span class="n">residuals</span> <span class="o">--------------------+</span>     <span class="o">|</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">x</span> <span class="o">------------------------------------------------+</span>  <span class="o">|</span>
          <span class="n">Dimension</span> <span class="n">of</span> <span class="n">y</span> <span class="o">---------------------------------------------------+</span>
</pre></div>
</div>
<p>The framework can currently accommodate cost functions of up to 10
independent variables, and there is no limit on the dimensionality
of each of them.</p>
<p>The <tt class="docutils literal"><span class="pre">CENTRAL</span></tt> difference method is considerably more accurate at
the cost of twice as many function evaluations than forward
difference. Consider using central differences begin with, and only
after that works, trying forward difference to improve performance.</p>
<p><strong>WARNING</strong> A common beginner&#8217;s error when first using
NumericDiffCostFunction is to get the sizing wrong. In particular,
there is a tendency to set the template parameters to (dimension of
residual, number of parameters) instead of passing a dimension
parameter for <em>every parameter</em>. In the example above, that would
be <tt class="docutils literal"><span class="pre">&lt;MyScalarCostFunctor,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></tt>, which is missing the last <tt class="docutils literal"><span class="pre">2</span></tt>
argument. Please be careful when setting the size parameters.</p>
<p><strong>Alternate Interface</strong></p>
<p>For a variety of reason, including compatibility with legacy code,
<a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a> can also take
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> objects as input. The following describes
how.</p>
<p>To get a numerically differentiated cost function, define a
subclass of <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> such that the
<a class="reference internal" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="CostFunction::Evaluate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></tt></a> function ignores the <tt class="docutils literal"><span class="pre">jacobians</span></tt>
parameter. The numeric differentiation wrapper will fill in the
jacobian parameter if necessary by repeatedly calling the
<a class="reference internal" href="#CostFunction::Evaluate__doubleCPCP.doubleP.doublePP" title="CostFunction::Evaluate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">CostFunction::Evaluate()</span></tt></a> with small changes to the
appropriate parameters, and computing the slope. For performance,
the numeric differentiation wrapper class is templated on the
concrete cost function, even though it could be implemented only in
terms of the <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> interface.</p>
<p>The numerically differentiated version of a cost function for a
cost function can be constructed as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span>
    <span class="o">=</span> <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunction</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">MyCostFunction</span><span class="p">(...),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">MyCostFunction</span></tt> has 1 residual and 2 parameter blocks with
sizes 4 and 8 respectively. Look at the tests for a more detailed
example.</p>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="dynamicnumericdiffcostfunction">
<h2><a class="reference internal" href="#DynamicNumericDiffCostFunction" title="DynamicNumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></tt></a><a class="headerlink" href="#dynamicnumericdiffcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="DynamicNumericDiffCostFunction">
<em class="property">class </em><tt class="descname">DynamicNumericDiffCostFunction</tt><a class="headerlink" href="#DynamicNumericDiffCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a> <a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a>
requires that the number of parameter blocks and their sizes be
known at compile time. It also has an upper limit of 10 parameter
blocks. In a number of applications, this is not enough.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CostFunctor</span><span class="p">,</span> <span class="n">NumericDiffMethod</span> <span class="n">method</span> <span class="o">=</span> <span class="n">CENTRAL</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DynamicNumericDiffCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>In such cases when numeric differentiation is desired,
<a class="reference internal" href="#DynamicNumericDiffCostFunction" title="DynamicNumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></tt></a> can be used.</p>
<p>Like <a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a> the user must define a
functor, but the signature of the functor differs slightly. The
expected interface for the cost functors is:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">MyCostFunctor</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Since the sizing of the parameters is done at runtime, you must
also specify the sizes after creating the dynamic numeric diff cost
function. For example:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">DynamicNumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">MyCostFunctor</span><span class="o">&gt;</span> <span class="n">cost_function</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">MyCostFunctor</span><span class="p">());</span>
<span class="n">cost_function</span><span class="p">.</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">cost_function</span><span class="p">.</span><span class="n">AddParameterBlock</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">cost_function</span><span class="p">.</span><span class="n">SetNumResiduals</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>As a rule of thumb, try using <a class="reference internal" href="#NumericDiffCostFunction" title="NumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffCostFunction</span></tt></a> before
you use <a class="reference internal" href="#DynamicNumericDiffCostFunction" title="DynamicNumericDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">DynamicNumericDiffCostFunction</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="numericdifffunctor">
<h2><a class="reference internal" href="#NumericDiffFunctor" title="NumericDiffFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffFunctor</span></tt></a><a class="headerlink" href="#numericdifffunctor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NumericDiffFunctor">
<em class="property">class </em><tt class="descname">NumericDiffFunctor</tt><a class="headerlink" href="#NumericDiffFunctor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes parts of a cost function can be differentiated
automatically or analytically but others require numeric
differentiation. <a class="reference internal" href="#NumericDiffFunctor" title="NumericDiffFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffFunctor</span></tt></a> is a wrapper class
that takes a variadic functor evaluating a function, numerically
differentiates it and makes it available as a templated functor so
that it can be easily used as part of Ceres&#8217; automatic
differentiation framework.</p>
<p>For example, let us assume that</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">IntrinsicProjection</span>
  <span class="nf">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observations</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">calibration</span><span class="p">,</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>is a functor that implements the projection of a point in its local
coordinate system onto its image plane and subtracts it from the
observed point projection.</p>
<p>Now we would like to compose the action of this functor with the
action of camera extrinsics, i.e., rotation and translation, which
is given by the following templated function</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                             <span class="n">T</span><span class="o">*</span> <span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>To compose the extrinsics and intrinsics, we can construct a
<tt class="docutils literal"><span class="pre">CameraProjection</span></tt> functor as follows.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
   <span class="k">typedef</span> <span class="n">NumericDiffFunctor</span><span class="o">&lt;</span><span class="n">IntrinsicProjection</span><span class="p">,</span> <span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span>
      <span class="n">IntrinsicProjectionFunctor</span><span class="p">;</span>

  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">intrinsic_projection_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">IntrinsicProjectionFunctor</span><span class="p">(</span><span class="n">observation</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">intrinsic_projection_</span><span class="p">)(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">IntrinsicProjectionFunctor</span><span class="o">&gt;</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, we made the choice of using <tt class="docutils literal"><span class="pre">CENTRAL</span></tt> differences to compute
the jacobian of <tt class="docutils literal"><span class="pre">IntrinsicProjection</span></tt>.</p>
<p>Now, we are ready to construct an automatically differentiated cost
function as</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">CameraProjection</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">(</span>
       <span class="k">new</span> <span class="n">CameraProjection</span><span class="p">(</span><span class="n">observations</span><span class="p">));</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cost_function</span></tt> now seamlessly integrates automatic
differentiation of <tt class="docutils literal"><span class="pre">RotateAndTranslatePoint</span></tt> with a numerically
differentiated version of <tt class="docutils literal"><span class="pre">IntrinsicProjection</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="costfunctiontofunctor">
<h2><a class="reference internal" href="#CostFunctionToFunctor" title="CostFunctionToFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a><a class="headerlink" href="#costfunctiontofunctor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="CostFunctionToFunctor">
<em class="property">class </em><tt class="descname">CostFunctionToFunctor</tt><a class="headerlink" href="#CostFunctionToFunctor" title="Permalink to this definition">¶</a></dt>
<dd><p>Just like <a class="reference internal" href="#NumericDiffFunctor" title="NumericDiffFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NumericDiffFunctor</span></tt></a> allows numeric
differentiation to be mixed with automatic differentiation,
<a class="reference internal" href="#CostFunctionToFunctor" title="CostFunctionToFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a> provides an even more general
mechanism.  <a class="reference internal" href="#CostFunctionToFunctor" title="CostFunctionToFunctor"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunctionToFunctor</span></tt></a> is an adapter class that
allows users to use <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> objects in templated
functors which are to be used for automatic differentiation.  This
allows the user to seamlessly mix analytic, numeric and automatic
differentiation.</p>
<p>For example, let us assume that</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">IntrinsicProjection</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">observations</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                          <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>is a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> that implements the projection of a
point in its local coordinate system onto its image plane and
subtracts it from the observed point projection. It can compute its
residual and either via analytic or numerical differentiation can
compute its jacobians.</p>
<p>Now we would like to compose the action of this
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> with the action of camera extrinsics, i.e.,
rotation and translation. Say we have a templated function</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                             <span class="n">T</span><span class="o">*</span> <span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Then we can now do the following,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">CameraProjection</span> <span class="p">{</span>
  <span class="n">CameraProjection</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">observation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">intrinsic_projection_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">CostFunctionToFunctor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">IntrinsicProjection</span><span class="p">(</span><span class="n">observation_</span><span class="p">)));</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">rotation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">intrinsics</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">point</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">transformed_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">RotateAndTranslatePoint</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">);</span>

    <span class="c1">// Note that we call intrinsic_projection_, just like it was</span>
    <span class="c1">// any other templated functor.</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">intrinsic_projection_</span><span class="p">)(</span><span class="n">intrinsics</span><span class="p">,</span> <span class="n">transformed_point</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">CostFunctionToFunctor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">intrinsic_projection_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="conditionedcostfunction">
<h2><a class="reference internal" href="#ConditionedCostFunction" title="ConditionedCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ConditionedCostFunction</span></tt></a><a class="headerlink" href="#conditionedcostfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ConditionedCostFunction">
<em class="property">class </em><tt class="descname">ConditionedCostFunction</tt><a class="headerlink" href="#ConditionedCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This class allows you to apply different conditioning to the residual
values of a wrapped cost function. An example where this is useful is
where you have an existing cost function that produces N values, but you
want the total cost to be something other than just the sum of these
squared values - maybe you want to apply a different scaling to some
values, to change their contribution to the cost.</p>
<p>Usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  my_cost_function produces N residuals</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">my_cost_function</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">my_cost_function</span><span class="o">-&gt;</span><span class="n">num_residuals</span><span class="p">());</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">CostFunction</span><span class="o">*&gt;</span> <span class="n">conditioners</span><span class="p">;</span>

<span class="c1">//  Make N 1x1 cost functions (1 parameter, 1 residual)</span>
<span class="n">CostFunction</span><span class="o">*</span> <span class="n">f_1</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">conditioners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f_1</span><span class="p">);</span>

<span class="n">CostFunction</span><span class="o">*</span> <span class="n">f_N</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">conditioners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">f_N</span><span class="p">);</span>
<span class="n">ConditionedCostFunction</span><span class="o">*</span> <span class="n">ccf</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">ConditionedCostFunction</span><span class="p">(</span><span class="n">my_cost_function</span><span class="p">,</span> <span class="n">conditioners</span><span class="p">);</span>
</pre></div>
</div>
<p>Now <tt class="docutils literal"><span class="pre">ccf</span></tt> &#8216;s <tt class="docutils literal"><span class="pre">residual[i]</span></tt> (i=0..N-1) will be passed though the
<span class="math">\(i^{\text{th}}\)</span> conditioner.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ccf_residual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_i</span><span class="p">(</span><span class="n">my_cost_function_residual</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>and the Jacobian will be affected appropriately.</p>
</dd></dl>

</div>
<div class="section" id="normalprior">
<h2><a class="reference internal" href="#NormalPrior" title="NormalPrior"><tt class="xref cpp cpp-class docutils literal"><span class="pre">NormalPrior</span></tt></a><a class="headerlink" href="#normalprior" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NormalPrior">
<em class="property">class </em><tt class="descname">NormalPrior</tt><a class="headerlink" href="#NormalPrior" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NormalPrior</span><span class="o">:</span> <span class="k">public</span> <span class="n">CostFunction</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// Check that the number of rows in the vector b are the same as the</span>
  <span class="c1">// number of columns in the matrix A, crash otherwise.</span>
  <span class="n">NormalPrior</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>Implements a cost function of the form</p>
<div class="math">
\[cost(x) = ||A(x - b)||^2\]</div>
<p>where, the matrix A and the vector b are fixed and x is the
variable. In case the user is interested in implementing a cost
function of the form</p>
</div></blockquote>
<div class="math">
\[cost(x) = (x - \mu)^T S^{-1} (x - \mu)\]</div>
<p>where, <span class="math">\(\mu\)</span> is a vector and <span class="math">\(S\)</span> is a covariance matrix,
then, <span class="math">\(A = S^{-1/2}\)</span>, i.e the matrix <span class="math">\(A\)</span> is the square
root of the inverse of the covariance, also known as the stiffness
matrix. There are however no restrictions on the shape of
<span class="math">\(A\)</span>. It is free to be rectangular, which would be the case if
the covariance matrix <span class="math">\(S\)</span> is rank deficient.</p>
</dd></dl>

</div>
<div class="section" id="lossfunction">
<span id="section-loss-function"></span><h2><a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a><a class="headerlink" href="#lossfunction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LossFunction">
<em class="property">class </em><tt class="descname">LossFunction</tt><a class="headerlink" href="#LossFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>For least squares problems where the minimization may encounter
input terms that contain outliers, that is, completely bogus
measurements, it is important to use a loss function that reduces
their influence.</p>
<p>Consider a structure from motion problem. The unknowns are 3D
points and camera parameters, and the measurements are image
coordinates describing the expected reprojected position for a
point in a camera. For example, we want to model the geometry of a
street scene with fire hydrants and cars, observed by a moving
camera with unknown parameters, and the only 3D points we care
about are the pointy tippy-tops of the fire hydrants. Our magic
image processing algorithm, which is responsible for producing the
measurements that are input to Ceres, has found and matched all
such tippy-tops in all image frames, except that in one of the
frame it mistook a car&#8217;s headlight for a hydrant. If we didn&#8217;t do
anything special the residual for the erroneous measurement will
result in the entire solution getting pulled away from the optimum
to reduce the large error that would otherwise be attributed to the
wrong measurement.</p>
<p>Using a robust loss function, the cost for large residuals is
reduced. In the example above, this leads to outlier terms getting
down-weighted so they do not overly influence the final solution.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LossFunction</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The key method is <tt class="xref cpp cpp-func docutils literal"><span class="pre">LossFunction::Evaluate()</span></tt>, which given a
non-negative scalar <tt class="docutils literal"><span class="pre">s</span></tt>, computes</p>
<div class="math">
\[\begin{split}out = \begin{bmatrix}\rho(s), &amp; \rho'(s), &amp; \rho''(s)\end{bmatrix}\end{split}\]</div>
<p>Here the convention is that the contribution of a term to the cost
function is given by <span class="math">\(\frac{1}{2}\rho(s)\)</span>, where <span class="math">\(s
=\|f_i\|^2\)</span>. Calling the method with a negative value of <span class="math">\(s\)</span>
is an error and the implementations are not required to handle that
case.</p>
<p>Most sane choices of <span class="math">\(\rho\)</span> satisfy:</p>
<div class="math">
\[\begin{split}\rho(0) &amp;= 0\\
\rho'(0) &amp;= 1\\
\rho'(s) &amp;&lt; 1 \text{ in the outlier region}\\
\rho''(s) &amp;&lt; 0 \text{ in the outlier region}\end{split}\]</div>
<p>so that they mimic the squared cost for small residuals.</p>
<p><strong>Scaling</strong></p>
<p>Given one robustifier <span class="math">\(\rho(s)\)</span> one can change the length
scale at which robustification takes place, by adding a scale
factor <span class="math">\(a &gt; 0\)</span> which gives us <span class="math">\(\rho(s,a) = a^2 \rho(s /
a^2)\)</span> and the first and second derivatives as <span class="math">\(\rho'(s /
a^2)\)</span> and <span class="math">\((1 / a^2) \rho''(s / a^2)\)</span> respectively.</p>
<p>The reason for the appearance of squaring is that <span class="math">\(a\)</span> is in
the units of the residual vector norm whereas <span class="math">\(s\)</span> is a squared
norm. For applications it is more convenient to specify <span class="math">\(a\)</span> than
its square.</p>
</dd></dl>

<div class="section" id="instances">
<h3>Instances<a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>Ceres includes a number of predefined loss functions. For simplicity
we described their unscaled versions. The figure below illustrates
their shape graphically. More details can be found in
<tt class="docutils literal"><span class="pre">include/ceres/loss_function.h</span></tt>.</p>
<div class="figure align-center" style="width: 500px">
<a class="reference internal image-reference" href="_images/loss.png"><img alt="_images/loss.png" src="_images/loss.png" style="height: 400px;" /></a>
<p class="caption">Shape of the various common loss functions.</p>
</div>
<dl class="class">
<dt id="TrivialLoss">
<em class="property">class </em><tt class="descname">TrivialLoss</tt><a class="headerlink" href="#TrivialLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = s\]</div>
</dd></dl>

<dl class="class">
<dt id="HuberLoss">
<em class="property">class </em><tt class="descname">HuberLoss</tt><a class="headerlink" href="#HuberLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\begin{split}\rho(s) = \begin{cases} s &amp; s \le 1\\ 2 \sqrt{s} - 1 &amp; s &gt; 1 \end{cases}\end{split}\]</div>
</dd></dl>

<dl class="class">
<dt id="SoftLOneLoss">
<em class="property">class </em><tt class="descname">SoftLOneLoss</tt><a class="headerlink" href="#SoftLOneLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = 2 (\sqrt{1+s} - 1)\]</div>
</dd></dl>

<dl class="class">
<dt id="CauchyLoss">
<em class="property">class </em><tt class="descname">CauchyLoss</tt><a class="headerlink" href="#CauchyLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = \log(1 + s)\]</div>
</dd></dl>

<dl class="class">
<dt id="ArctanLoss">
<em class="property">class </em><tt class="descname">ArctanLoss</tt><a class="headerlink" href="#ArctanLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s) = \arctan(s)\]</div>
</dd></dl>

<dl class="class">
<dt id="TolerantLoss">
<em class="property">class </em><tt class="descname">TolerantLoss</tt><a class="headerlink" href="#TolerantLoss" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\rho(s,a,b) = b \log(1 + e^{(s - a) / b}) - b \log(1 + e^{-a / b})\]</div>
</dd></dl>

<dl class="class">
<dt id="ComposedLoss">
<em class="property">class </em><tt class="descname">ComposedLoss</tt><a class="headerlink" href="#ComposedLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two loss functions <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt>, implements the loss
function <tt class="docutils literal"><span class="pre">h(s)</span> <span class="pre">=</span> <span class="pre">f(g(s))</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ComposedLoss</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LossFunction</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">ComposedLoss</span><span class="p">(</span><span class="k">const</span> <span class="n">LossFunction</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span>
                        <span class="n">Ownership</span> <span class="n">ownership_f</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">LossFunction</span><span class="o">*</span> <span class="n">g</span><span class="p">,</span>
                        <span class="n">Ownership</span> <span class="n">ownership_g</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="ScaledLoss">
<em class="property">class </em><tt class="descname">ScaledLoss</tt><a class="headerlink" href="#ScaledLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes you want to simply scale the output value of the
robustifier. For example, you might want to weight different error
terms differently (e.g., weight pixel reprojection errors
differently from terrain errors).</p>
<p>Given a loss function <span class="math">\(\rho(s)\)</span> and a scalar <span class="math">\(a\)</span>, <a class="reference internal" href="#ScaledLoss" title="ScaledLoss"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ScaledLoss</span></tt></a>
implements the function <span class="math">\(a \rho(s)\)</span>.</p>
<p>Since we treat the a <tt class="docutils literal"><span class="pre">NULL</span></tt> Loss function as the Identity loss
function, <span class="math">\(rho\)</span> = <tt class="docutils literal"><span class="pre">NULL</span></tt>: is a valid input and will result
in the input being scaled by <span class="math">\(a\)</span>. This provides a simple way
of implementing a scaled ResidualBlock.</p>
</dd></dl>

<dl class="class">
<dt id="LossFunctionWrapper">
<em class="property">class </em><tt class="descname">LossFunctionWrapper</tt><a class="headerlink" href="#LossFunctionWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes after the optimization problem has been constructed, we
wish to mutate the scale of the loss function. For example, when
performing estimation from data which has substantial outliers,
convergence can be improved by starting out with a large scale,
optimizing the problem and then reducing the scale. This can have
better convergence behavior than just using a loss function with a
small scale.</p>
<p>This templated class allows the user to implement a loss function
whose scale can be mutated after an optimization problem has been
constructed. e.g,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

<span class="c1">// Add parameter blocks</span>

<span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AutoDiffCostFunction</span> <span class="o">&lt;</span> <span class="n">UW_Camera_Mapper</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">UW_Camera_Mapper</span><span class="p">(</span><span class="n">feature_x</span><span class="p">,</span> <span class="n">feature_y</span><span class="p">));</span>

<span class="n">LossFunctionWrapper</span><span class="o">*</span> <span class="nf">loss_function</span><span class="p">(</span><span class="k">new</span> <span class="n">HuberLoss</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="n">loss_function</span><span class="p">,</span> <span class="n">parameters</span><span class="p">);</span>

<span class="n">Solver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">Solver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
<span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>

<span class="n">loss_function</span><span class="o">-&gt;</span><span class="n">Reset</span><span class="p">(</span><span class="k">new</span> <span class="n">HuberLoss</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">TAKE_OWNERSHIP</span><span class="p">);</span>
<span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p>Let us consider a problem with a single problem and a single parameter
block.</p>
<div class="math">
\[\min_x \frac{1}{2}\rho(f^2(x))\]</div>
<p>Then, the robustified gradient and the Gauss-Newton Hessian are</p>
<div class="math">
\[\begin{split}g(x) &amp;= \rho'J^\top(x)f(x)\\
H(x) &amp;= J^\top(x)\left(\rho' + 2 \rho''f(x)f^\top(x)\right)J(x)\end{split}\]</div>
<p>where the terms involving the second derivatives of <span class="math">\(f(x)\)</span> have
been ignored. Note that <span class="math">\(H(x)\)</span> is indefinite if
<span class="math">\(\rho''f(x)^\top f(x) + \frac{1}{2}\rho' &lt; 0\)</span>. If this is not
the case, then its possible to re-weight the residual and the Jacobian
matrix such that the corresponding linear least squares problem for
the robustified Gauss-Newton step.</p>
<p>Let <span class="math">\(\alpha\)</span> be a root of</p>
<div class="math">
\[\frac{1}{2}\alpha^2 - \alpha - \frac{\rho''}{\rho'}\|f(x)\|^2 = 0.\]</div>
<p>Then, define the rescaled residual and Jacobian as</p>
<div class="math">
\[\begin{split}\tilde{f}(x) &amp;= \frac{\sqrt{\rho'}}{1 - \alpha} f(x)\\
\tilde{J}(x) &amp;= \sqrt{\rho'}\left(1 - \alpha
                \frac{f(x)f^\top(x)}{\left\|f(x)\right\|^2} \right)J(x)\end{split}\]</div>
<p>In the case <span class="math">\(2 \rho''\left\|f(x)\right\|^2 + \rho' \lesssim 0\)</span>,
we limit <span class="math">\(\alpha \le 1- \epsilon\)</span> for some small
<span class="math">\(\epsilon\)</span>. For more details see <a class="reference internal" href="bibliography.html#triggs" id="id1">[Triggs]</a>.</p>
<p>With this simple rescaling, one can use any Jacobian based non-linear
least squares algorithm to robustified non-linear least squares
problems.</p>
</div>
</div>
<div class="section" id="localparameterization">
<h2><a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a><a class="headerlink" href="#localparameterization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LocalParameterization">
<em class="property">class </em><tt class="descname">LocalParameterization</tt><a class="headerlink" href="#LocalParameterization" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LocalParameterization</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">LocalParameterization</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Plus</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                    <span class="kt">double</span><span class="o">*</span> <span class="n">x_plus_delta</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ComputeJacobian</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">jacobian</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">GlobalSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">LocalSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sometimes the parameters <span class="math">\(x\)</span> can overparameterize a
problem. In that case it is desirable to choose a parameterization
to remove the null directions of the cost. More generally, if
<span class="math">\(x\)</span> lies on a manifold of a smaller dimension than the
ambient space that it is embedded in, then it is numerically and
computationally more effective to optimize it using a
parameterization that lives in the tangent space of that manifold
at each point.</p>
<p>For example, a sphere in three dimensions is a two dimensional
manifold, embedded in a three dimensional space. At each point on
the sphere, the plane tangent to it defines a two dimensional
tangent space. For a cost function defined on this sphere, given a
point <span class="math">\(x\)</span>, moving in the direction normal to the sphere at
that point is not useful. Thus a better way to parameterize a point
on a sphere is to optimize over two dimensional vector
<span class="math">\(\Delta x\)</span> in the tangent space at the point on the sphere
point and then &#8220;move&#8221; to the point <span class="math">\(x + \Delta x\)</span>, where the
move operation involves projecting back onto the sphere. Doing so
removes a redundant dimension from the optimization, making it
numerically more robust and efficient.</p>
<p>More generally we can define a function</p>
<div class="math">
\[x' = \boxplus(x, \Delta x),\]</div>
<p>where <span class="math">\(x'\)</span> has the same size as <span class="math">\(x\)</span>, and <span class="math">\(\Delta
x\)</span> is of size less than or equal to <span class="math">\(x\)</span>. The function
<span class="math">\(\boxplus\)</span>, generalizes the definition of vector
addition. Thus it satisfies the identity</p>
<div class="math">
\[\boxplus(x, 0) = x,\quad \forall x.\]</div>
<p>Instances of <a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a> implement the
<span class="math">\(\boxplus\)</span> operation and its derivative with respect to
<span class="math">\(\Delta x\)</span> at <span class="math">\(\Delta x = 0\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParameterization::GlobalSize">
int <tt class="descclassname">LocalParameterization::</tt><tt class="descname">GlobalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#LocalParameterization::GlobalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the ambient space in which the parameter block
<span class="math">\(x\)</span> lives.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParamterization::LocaLocalSize">
int <tt class="descclassname">LocalParamterization::</tt><tt class="descname">LocaLocalSize</tt><big>(</big><big>)</big><a class="headerlink" href="#LocalParamterization::LocaLocalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the tangent space
that <span class="math">\(\Delta x\)</span> lives in.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParameterization::Plus__doubleCP.doubleCP.doublePC">
bool <tt class="descclassname">LocalParameterization::</tt><tt class="descname">Plus</tt><big>(</big>const double* <em>x</em>, const double* <em>delta</em>, double* <em>x_plus_delta</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#LocalParameterization::Plus__doubleCP.doubleCP.doublePC" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#LocalParameterization::Plus__doubleCP.doubleCP.doublePC" title="LocalParameterization::Plus"><tt class="xref cpp cpp-func docutils literal"><span class="pre">LocalParameterization::Plus()</span></tt></a> implements <span class="math">\(\boxplus(x,\Delta x)\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="LocalParameterization::ComputeJacobian__doubleCP.doublePC">
bool <tt class="descclassname">LocalParameterization::</tt><tt class="descname">ComputeJacobian</tt><big>(</big>const double* <em>x</em>, double* <em>jacobian</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#LocalParameterization::ComputeJacobian__doubleCP.doublePC" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jacobian matrix</p>
<div class="math">
\[J = \left . \frac{\partial }{\partial \Delta x} \boxplus(x,\Delta x)\right|_{\Delta x = 0}\]</div>
<p>in row major form.</p>
</dd></dl>

<div class="section" id="id2">
<h3>Instances<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="IdentityParameterization">
<em class="property">class </em><tt class="descname">IdentityParameterization</tt><a class="headerlink" href="#IdentityParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>A trivial version of <span class="math">\(\boxplus\)</span> is when <span class="math">\(\Delta x\)</span> is
of the same size as <span class="math">\(x\)</span> and</p>
<div class="math">
\[\boxplus(x, \Delta x) = x + \Delta x\]</div>
</dd></dl>

<dl class="class">
<dt id="SubsetParameterization">
<em class="property">class </em><tt class="descname">SubsetParameterization</tt><a class="headerlink" href="#SubsetParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>A more interesting case if <span class="math">\(x\)</span> is a two dimensional vector,
and the user wishes to hold the first coordinate constant. Then,
<span class="math">\(\Delta x\)</span> is a scalar and <span class="math">\(\boxplus\)</span> is defined as</p>
<div class="math">
\[\begin{split}\boxplus(x, \Delta x) = x + \left[ \begin{array}{c} 0 \\ 1
                            \end{array} \right] \Delta x\end{split}\]</div>
<p><a class="reference internal" href="#SubsetParameterization" title="SubsetParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">SubsetParameterization</span></tt></a> generalizes this construction to
hold any part of a parameter block constant.</p>
</dd></dl>

<dl class="class">
<dt id="QuaternionParameterization">
<em class="property">class </em><tt class="descname">QuaternionParameterization</tt><a class="headerlink" href="#QuaternionParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p>Another example that occurs commonly in Structure from Motion
problems is when camera rotations are parameterized using a
quaternion. There, it is useful only to make updates orthogonal to
that 4-vector defining the quaternion. One way to do this is to let
<span class="math">\(\Delta x\)</span> be a 3 dimensional vector and define
<span class="math">\(\boxplus\)</span> to be</p>
<blockquote>
<div><div class="math" id="equation-quaternion">
<span class="eqno">(3)</span>\[\boxplus(x, \Delta x) = \left[ \cos(|\Delta x|), \frac{\sin\left(|\Delta x|\right)}{|\Delta x|} \Delta x \right] * x\]</div>
</div></blockquote>
<p>The multiplication between the two 4-vectors on the right hand side
is the standard quaternion
product. <a class="reference internal" href="#QuaternionParameterization" title="QuaternionParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">QuaternionParameterization</span></tt></a> is an implementation
of <a href="#equation-quaternion">(3)</a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="autodifflocalparameterization">
<h2><a class="reference internal" href="#AutoDiffLocalParameterization" title="AutoDiffLocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffLocalParameterization</span></tt></a><a class="headerlink" href="#autodifflocalparameterization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="AutoDiffLocalParameterization">
<em class="property">class </em><tt class="descname">AutoDiffLocalParameterization</tt><a class="headerlink" href="#AutoDiffLocalParameterization" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#AutoDiffLocalParameterization" title="AutoDiffLocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffLocalParameterization</span></tt></a> does for
<a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a> what <a class="reference internal" href="#AutoDiffCostFunction" title="AutoDiffCostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">AutoDiffCostFunction</span></tt></a>
does for <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a>. It allows the user to define a
templated functor that implements the
<a class="reference internal" href="#LocalParameterization::Plus__doubleCP.doubleCP.doublePC" title="LocalParameterization::Plus"><tt class="xref cpp cpp-func docutils literal"><span class="pre">LocalParameterization::Plus()</span></tt></a> operation and it uses automatic
differentiation to implement the computation of the Jacobian.</p>
<p>To get an auto differentiated local parameterization, you must
define a class with a templated operator() (a functor) that computes</p>
<blockquote>
<div><div class="math">
\[x' = \boxplus(x, \Delta x),\]</div>
</div></blockquote>
<p>For example, Quaternions have a three dimensional local
parameterization. It&#8217;s plus operation can be implemented as (taken
from <a class="reference external" href="https://ceres-solver.googlesource.com/ceres-solver/+/master/include/ceres/local_parameterization.h">internal/ceres/auto_diff_local_parameterization_test.cc</a>
)</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">QuaternionPlus</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">x_plus_delta</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">squared_norm_delta</span> <span class="o">=</span>
        <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">T</span> <span class="n">q_delta</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">squared_norm_delta</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">T</span> <span class="n">norm_delta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">squared_norm_delta</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">T</span> <span class="n">sin_delta_by_delta</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">norm_delta</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm_delta</span><span class="p">;</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">norm_delta</span><span class="p">);</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_delta_by_delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_delta_by_delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_delta_by_delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// We do not just use q_delta = [1,0,0,0] here because that is a</span>
      <span class="c1">// constant and when used for automatic differentiation will</span>
      <span class="c1">// lead to a zero derivative. Instead we take a first order</span>
      <span class="c1">// approximation and evaluate it at zero.</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="n">q_delta</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">Quaternionproduct</span><span class="p">(</span><span class="n">q_delta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x_plus_delta</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>Then given this struct, the auto differentiated local
parameterization can now be constructed as</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalParameterization</span><span class="o">*</span> <span class="n">local_parameterization</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AutoDiffLocalParameterization</span><span class="o">&lt;</span><span class="n">QuaternionPlus</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
                                                      <span class="o">|</span>  <span class="o">|</span>
                           <span class="n">Global</span> <span class="n">Size</span> <span class="o">---------------+</span>  <span class="o">|</span>
                           <span class="n">Local</span> <span class="n">Size</span> <span class="o">-------------------+</span>
</pre></div>
</div>
<p><strong>WARNING:</strong> Since the functor will get instantiated with different
types for <tt class="docutils literal"><span class="pre">T</span></tt>, you must to convert from other numeric types to
<tt class="docutils literal"><span class="pre">T</span></tt> before mixing computations with other variables of type
<tt class="docutils literal"><span class="pre">T</span></tt>. In the example above, this is seen where instead of using
<tt class="docutils literal"><span class="pre">k_</span></tt> directly, <tt class="docutils literal"><span class="pre">k_</span></tt> is wrapped with <tt class="docutils literal"><span class="pre">T(k_)</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="problem">
<h2><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a><a class="headerlink" href="#problem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Problem">
<em class="property">class </em><tt class="descname">Problem</tt><a class="headerlink" href="#Problem" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> holds the robustified bounds constrained
non-linear least squares problem <a href="#equation-ceresproblem">(1)</a>. To create a
least squares problem, use the <a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a>
and <a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a> methods.</p>
<p>For example a problem containing 3 parameter blocks of sizes 3, 4
and 5 respectively and two residual blocks of size 2 and 6:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">double</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">x3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.0</span> <span class="p">};</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyUnaryCostFunction</span><span class="p">(...),</span> <span class="n">x1</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyBinaryCostFunction</span><span class="p">(...),</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a> as the name implies, adds a
residual block to the problem. It adds a <a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a>, an
optional <a class="reference internal" href="#LossFunction" title="LossFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LossFunction</span></tt></a> and connects the
<a class="reference internal" href="#CostFunction" title="CostFunction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CostFunction</span></tt></a> to a set of parameter block.</p>
<p>The cost function carries with it information about the sizes of
the parameter blocks it expects. The function checks that these
match the sizes of the parameter blocks listed in
<tt class="docutils literal"><span class="pre">parameter_blocks</span></tt>. The program aborts if a mismatch is
detected. <tt class="docutils literal"><span class="pre">loss_function</span></tt> can be <tt class="docutils literal"><span class="pre">NULL</span></tt>, in which case the cost
of the term is just the squared norm of the residuals.</p>
<p>The user has the option of explicitly adding the parameter blocks
using <a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a>. This causes additional
correctness checking; however, <a class="reference internal" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Problem::AddResidualBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddResidualBlock()</span></tt></a>
implicitly adds the parameter blocks if they are not present, so
calling <a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a> explicitly is not
required.</p>
<p><a class="reference internal" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Problem::AddParameterBlock"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::AddParameterBlock()</span></tt></a> explicitly adds a parameter
block to the <a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a>. Optionally it allows the user to
associate a <a class="reference internal" href="#LocalParameterization" title="LocalParameterization"><tt class="xref cpp cpp-class docutils literal"><span class="pre">LocalParameterization</span></tt></a> object with the
parameter block too. Repeated calls with the same arguments are
ignored. Repeated calls with the same double pointer but a
different size results in undefined behavior.</p>
<p>You can set any parameter block to be constant using
<a class="reference internal" href="#Problem::SetParameterBlockConstant__doubleP" title="Problem::SetParameterBlockConstant"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::SetParameterBlockConstant()</span></tt></a> and undo this using
<a class="reference internal" href="#Problem::SetParameterBlockVariable__doubleP" title="Problem::SetParameterBlockVariable"><tt class="xref cpp cpp-func docutils literal"><span class="pre">SetParameterBlockVariable()</span></tt></a>.</p>
<p>In fact you can set any number of parameter blocks to be constant,
and Ceres is smart enough to figure out what part of the problem
you have constructed depends on the parameter blocks that are free
to change and only spends time solving it. So for example if you
constructed a problem with a million parameter blocks and 2 million
residual blocks, but then set all but one parameter blocks to be
constant and say only 10 residual blocks depend on this one
non-constant parameter block. Then the computational effort Ceres
spends in solving this problem will be the same if you had defined
a problem with one parameter block and 10 residual blocks.</p>
<p><strong>Ownership</strong></p>
<p><a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a> by default takes ownership of the
<tt class="docutils literal"><span class="pre">cost_function</span></tt>, <tt class="docutils literal"><span class="pre">loss_function</span></tt> and <tt class="docutils literal"><span class="pre">local_parameterization</span></tt>
pointers. These objects remain live for the life of the
<a class="reference internal" href="#Problem" title="Problem"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem</span></tt></a>. If the user wishes to keep control over the
destruction of these objects, then they can do this by setting the
corresponding enums in the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Problem::Options</span></tt> struct.</p>
<p>Note that even though the Problem takes ownership of <tt class="docutils literal"><span class="pre">cost_function</span></tt>
and <tt class="docutils literal"><span class="pre">loss_function</span></tt>, it does not preclude the user from re-using
them in another residual block. The destructor takes care to call
delete on each <tt class="docutils literal"><span class="pre">cost_function</span></tt> or <tt class="docutils literal"><span class="pre">loss_function</span></tt> pointer only
once, regardless of how many residual blocks refer to them.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C">
ResidualBlockId <tt class="descclassname">Problem::</tt><tt class="descname">AddResidualBlock</tt><big>(</big>CostFunction* <em>cost_function</em>, LossFunction* <em>loss_function</em>, const vector&lt;double*&gt; <em>parameter_blocks</em><big>)</big><a class="headerlink" href="#Problem::AddResidualBlock__CostFunctionP.LossFunctionP.vector:doubleP:C" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a residual block to the overall cost function. The cost
function carries with it information about the sizes of the
parameter blocks it expects. The function checks that these match
the sizes of the parameter blocks listed in parameter_blocks. The
program aborts if a mismatch is detected. loss_function can be
NULL, in which case the cost of the term is just the squared norm
of the residuals.</p>
<p>The user has the option of explicitly adding the parameter blocks
using AddParameterBlock. This causes additional correctness
checking; however, AddResidualBlock implicitly adds the parameter
blocks if they are not present, so calling AddParameterBlock
explicitly is not required.</p>
<p>The Problem object by default takes ownership of the
cost_function and loss_function pointers. These objects remain
live for the life of the Problem object. If the user wishes to
keep control over the destruction of these objects, then they can
do this by setting the corresponding enums in the Options struct.</p>
<p>Note: Even though the Problem takes ownership of cost_function
and loss_function, it does not preclude the user from re-using
them in another residual block. The destructor takes care to call
delete on each cost_function or loss_function pointer only once,
regardless of how many residual blocks refer to them.</p>
<p>Example usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">double</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">};</span>
<span class="kt">double</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">};</span>
<span class="kt">double</span> <span class="n">x3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyUnaryCostFunction</span><span class="p">(...),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="k">new</span> <span class="n">MyBinaryCostFunction</span><span class="p">(...),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Problem::AddParameterBlock__doubleP.i.LocalParameterizationP">
void <tt class="descclassname">Problem::</tt><tt class="descname">AddParameterBlock</tt><big>(</big>double* <em>values</em>, int <em>size</em>, LocalParameterization* <em>local_parameterization</em><big>)</big><a class="headerlink" href="#Problem::AddParameterBlock__doubleP.i.LocalParameterizationP" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parameter block with appropriate size to the problem.
Repeated calls with the same arguments are ignored. Repeated calls
with the same double pointer but a different size results in
undefined behavior.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::AddParameterBlock__doubleP.i">
void <tt class="descclassname">Problem::</tt><tt class="descname">AddParameterBlock</tt><big>(</big>double* <em>values</em>, int <em>size</em><big>)</big><a class="headerlink" href="#Problem::AddParameterBlock__doubleP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parameter block with appropriate size and parameterization to
the problem. Repeated calls with the same arguments are
ignored. Repeated calls with the same double pointer but a
different size results in undefined behavior.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::RemoveResidualBlock__ResidualBlockId">
void <tt class="descclassname">Problem::</tt><tt class="descname">RemoveResidualBlock</tt><big>(</big>ResidualBlockId <em>residual_block</em><big>)</big><a class="headerlink" href="#Problem::RemoveResidualBlock__ResidualBlockId" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a residual block from the problem. Any parameters that the residual
block depends on are not removed. The cost and loss functions for the
residual block will not get deleted immediately; won&#8217;t happen until the
problem itself is deleted.  If Problem::Options::enable_fast_removal is
true, then the removal is fast (almost constant time). Otherwise, removing a
residual block will incur a scan of the entire Problem object to verify that
the residual_block represents a valid residual in the problem.</p>
<p><strong>WARNING:</strong> Removing a residual or parameter block will destroy
the implicit ordering, rendering the jacobian or residuals returned
from the solver uninterpretable. If you depend on the evaluated
jacobian, do not use remove! This may change in a future release.
Hold the indicated parameter block constant during optimization.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::RemoveParameterBlock__doubleP">
void <tt class="descclassname">Problem::</tt><tt class="descname">RemoveParameterBlock</tt><big>(</big>double* <em>values</em><big>)</big><a class="headerlink" href="#Problem::RemoveParameterBlock__doubleP" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a parameter block from the problem. The parameterization of
the parameter block, if it exists, will persist until the deletion
of the problem (similar to cost/loss functions in residual block
removal). Any residual blocks that depend on the parameter are also
removed, as described above in RemoveResidualBlock().  If
Problem::Options::enable_fast_removal is true, then
the removal is fast (almost constant time). Otherwise, removing a
parameter block will incur a scan of the entire Problem object.</p>
<p><strong>WARNING:</strong> Removing a residual or parameter block will destroy
the implicit ordering, rendering the jacobian or residuals returned
from the solver uninterpretable. If you depend on the evaluated
jacobian, do not use remove! This may change in a future release.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::SetParameterBlockConstant__doubleP">
void <tt class="descclassname">Problem::</tt><tt class="descname">SetParameterBlockConstant</tt><big>(</big>double* <em>values</em><big>)</big><a class="headerlink" href="#Problem::SetParameterBlockConstant__doubleP" title="Permalink to this definition">¶</a></dt>
<dd><p>Hold the indicated parameter block constant during optimization.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::SetParameterBlockVariable__doubleP">
void <tt class="descclassname">Problem::</tt><tt class="descname">SetParameterBlockVariable</tt><big>(</big>double* <em>values</em><big>)</big><a class="headerlink" href="#Problem::SetParameterBlockVariable__doubleP" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the indicated parameter to vary during optimization.</p>
</dd></dl>

<dl class="function">
<dt id="Problem::SetParameterization__doubleP.LocalParameterizationP">
void <tt class="descclassname">Problem::</tt><tt class="descname">SetParameterization</tt><big>(</big>double* <em>values</em>, LocalParameterization* <em>local_parameterization</em><big>)</big><a class="headerlink" href="#Problem::SetParameterization__doubleP.LocalParameterizationP" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the local parameterization for one of the parameter blocks.
The local_parameterization is owned by the Problem by default. It
is acceptable to set the same parameterization for multiple
parameters; the destructor is careful to delete local
parameterizations only once. The local parameterization can only be
set once per parameter, and cannot be changed once set.</p>
</dd></dl>

<dl class="class">
<dt id="Problem::EvaluateOptions">
<em class="property">class </em><tt class="descclassname">Problem::</tt><tt class="descname">EvaluateOptions</tt><a class="headerlink" href="#Problem::EvaluateOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Options struct that is used to control <tt class="xref cpp cpp-func docutils literal"><span class="pre">Problem::Evaluate()</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="Problem::EvaluateOptions::parameter_blocks__vector:doubleP:">
vector&lt;double*&gt; <tt class="descclassname">Problem::EvaluateOptions::</tt><tt class="descname">parameter_blocks</tt><a class="headerlink" href="#Problem::EvaluateOptions::parameter_blocks__vector:doubleP:" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of parameter blocks for which evaluation should be
performed. This vector determines the order in which parameter
blocks occur in the gradient vector and in the columns of the
jacobian matrix. If parameter_blocks is empty, then it is assumed
to be equal to a vector containing ALL the parameter
blocks. Generally speaking the ordering of the parameter blocks in
this case depends on the order in which they were added to the
problem and whether or not the user removed any parameter blocks.</p>
<p><strong>NOTE</strong> This vector should contain the same pointers as the ones
used to add parameter blocks to the Problem. These parameter block
should NOT point to new memory locations. Bad things will happen if
you do.</p>
</dd></dl>

<dl class="member">
<dt id="Problem::EvaluateOptions::residual_blocks__vector:ResidualBlockId:">
vector&lt;ResidualBlockId&gt; <tt class="descclassname">Problem::EvaluateOptions::</tt><tt class="descname">residual_blocks</tt><a class="headerlink" href="#Problem::EvaluateOptions::residual_blocks__vector:ResidualBlockId:" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of residual blocks for which evaluation should be
performed. This vector determines the order in which the residuals
occur, and how the rows of the jacobian are ordered. If
residual_blocks is empty, then it is assumed to be equal to the
vector containing all the parameter blocks.</p>
</dd></dl>

</div>
<div class="section" id="rotation-h">
<h2><tt class="docutils literal"><span class="pre">rotation.h</span></tt><a class="headerlink" href="#rotation-h" title="Permalink to this headline">¶</a></h2>
<p>Many applications of Ceres Solver involve optimization problems where
some of the variables correspond to rotations. To ease the pain of
work with the various representations of rotations (angle-axis,
quaternion and matrix) we provide a handy set of templated
functions. These functions are templated so that the user can use them
within Ceres Solver&#8217;s automatic differentiation framework.</p>
<dl class="function">
<dt id="AngleAxisToQuaternion:T:__TCP.TP">
void <tt class="descname">AngleAxisToQuaternion&lt;T&gt;</tt><big>(</big>T const* <em>angle_axis</em>, T* <em>quaternion</em><big>)</big><a class="headerlink" href="#AngleAxisToQuaternion:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a value in combined axis-angle representation to a
quaternion.</p>
<p>The value <tt class="docutils literal"><span class="pre">angle_axis</span></tt> is a triple whose norm is an angle in radians,
and whose direction is aligned with the axis of rotation, and
<tt class="docutils literal"><span class="pre">quaternion</span></tt> is a 4-tuple that will contain the resulting quaternion.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionToAngleAxis:T:__TCP.TP">
void <tt class="descname">QuaternionToAngleAxis&lt;T&gt;</tt><big>(</big>T const* <em>quaternion</em>, T* <em>angle_axis</em><big>)</big><a class="headerlink" href="#QuaternionToAngleAxis:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a quaternion to the equivalent combined axis-angle
representation.</p>
<p>The value <tt class="docutils literal"><span class="pre">quaternion</span></tt> must be a unit quaternion - it is not
normalized first, and <tt class="docutils literal"><span class="pre">angle_axis</span></tt> will be filled with a value
whose norm is the angle of rotation in radians, and whose direction
is the axis of rotation.</p>
</dd></dl>

<dl class="function">
<dt id="RotationMatrixToAngleAxis:T.row_stride.col_stride:__MatrixAdapter:TC.row_stride.col_stride:CR.TP">
void <tt class="descname">RotationMatrixToAngleAxis&lt;T, row_stride, col_stride&gt;</tt><big>(</big>const MatrixAdapter&lt;const T, row_stride, col_stride&gt;&amp; <em>R</em>, T* <em>angle_axis</em><big>)</big><a class="headerlink" href="#RotationMatrixToAngleAxis:T.row_stride.col_stride:__MatrixAdapter:TC.row_stride.col_stride:CR.TP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="AngleAxisToRotationMatrix:T.row_stride.col_stride:__TCP.MatrixAdapter:T.row_stride.col_stride:CR">
void <tt class="descname">AngleAxisToRotationMatrix&lt;T, row_stride, col_stride&gt;</tt><big>(</big>T const* <em>angle_axis</em>, const MatrixAdapter&lt;T, row_stride, col_stride&gt;&amp; <em>R</em><big>)</big><a class="headerlink" href="#AngleAxisToRotationMatrix:T.row_stride.col_stride:__TCP.MatrixAdapter:T.row_stride.col_stride:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RotationMatrixToAngleAxis:T:__TCP.TP">
void <tt class="descname">RotationMatrixToAngleAxis&lt;T&gt;</tt><big>(</big>T const* <em>R</em>, T* <em>angle_axis</em><big>)</big><a class="headerlink" href="#RotationMatrixToAngleAxis:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="AngleAxisToRotationMatrix:T:__TCP.TP">
void <tt class="descname">AngleAxisToRotationMatrix&lt;T&gt;</tt><big>(</big>T const* <em>angle_axis</em>, T* <em>R</em><big>)</big><a class="headerlink" href="#AngleAxisToRotationMatrix:T:__TCP.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between 3x3 rotation matrix with given column and row strides and
axis-angle rotation representations. The functions that take a pointer to T instead
of a MatrixAdapter assume a column major representation with unit row stride and a column stride of 3.</p>
</dd></dl>

<dl class="function">
<dt id="EulerAnglesToRotationMatrix:T.row_stride.col_stride:__TCP.MatrixAdapter:T.row_stride.col_stride:CR">
void <tt class="descname">EulerAnglesToRotationMatrix&lt;T, row_stride, col_stride&gt;</tt><big>(</big>const T* <em>euler</em>, const MatrixAdapter&lt;T, row_stride, col_stride&gt;&amp; <em>R</em><big>)</big><a class="headerlink" href="#EulerAnglesToRotationMatrix:T.row_stride.col_stride:__TCP.MatrixAdapter:T.row_stride.col_stride:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="EulerAnglesToRotationMatrix:T:__TCP.i.TP">
void <tt class="descname">EulerAnglesToRotationMatrix&lt;T&gt;</tt><big>(</big>const T* <em>euler</em>, int <em>row_stride</em>, T* <em>R</em><big>)</big><a class="headerlink" href="#EulerAnglesToRotationMatrix:T:__TCP.i.TP" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between 3x3 rotation matrix with given column and row strides and
Euler angle (in degrees) rotation representations.</p>
<p>The {pitch,roll,yaw} Euler angles are rotations around the {x,y,z}
axes, respectively.  They are applied in that same order, so the
total rotation R is Rz * Ry * Rx.</p>
<p>The function that takes a pointer to T as the rotation matrix assumes a row
major representation with unit column stride and a row stride of 3.
The additional parameter row_stride is required to be 3.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionToScaledRotation:T.row_stride.col_stride:__TCA.MatrixAdapter:T.row_stride.col_stride:CR">
void <tt class="descname">QuaternionToScaledRotation&lt;T, row_stride, col_stride&gt;</tt><big>(</big>const T <em>q</em>[4], const MatrixAdapter&lt;T, row_stride, col_stride&gt;&amp; <em>R</em><big>)</big><a class="headerlink" href="#QuaternionToScaledRotation:T.row_stride.col_stride:__TCA.MatrixAdapter:T.row_stride.col_stride:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="QuaternionToScaledRotation:T:__TCA.TA">
void <tt class="descname">QuaternionToScaledRotation&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], T <em>R</em>[3 * 3]<big>)</big><a class="headerlink" href="#QuaternionToScaledRotation:T:__TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a 4-vector to a 3x3 scaled rotation matrix.</p>
<p>The choice of rotation is such that the quaternion
<span class="math">\(\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0\end{bmatrix}\)</span> goes to an identity
matrix and for small <span class="math">\(a, b, c\)</span> the quaternion
<span class="math">\(\begin{bmatrix}1 &amp;a &amp;b &amp;c\end{bmatrix}\)</span> goes to the matrix</p>
<div class="math">
\[\begin{split}I + 2 \begin{bmatrix} 0 &amp; -c &amp; b \\ c &amp; 0 &amp; -a\\ -b &amp; a &amp; 0
      \end{bmatrix} + O(q^2)\end{split}\]</div>
<p>which corresponds to a Rodrigues approximation, the last matrix
being the cross-product matrix of <span class="math">\(\begin{bmatrix} a&amp; b&amp;
c\end{bmatrix}\)</span>. Together with the property that <span class="math">\(R(q1 * q2)
= R(q1) * R(q2)\)</span> this uniquely defines the mapping from <span class="math">\(q\)</span> to
<span class="math">\(R\)</span>.</p>
<p>In the function that accepts a pointer to T instead of a MatrixAdapter,
the rotation matrix <tt class="docutils literal"><span class="pre">R</span></tt> is a row-major matrix with unit column stride
and a row stride of 3.</p>
<p>No normalization of the quaternion is performed, i.e.
<span class="math">\(R = \|q\|^2  Q\)</span>, where <span class="math">\(Q\)</span> is an orthonormal matrix
such that <span class="math">\(\det(Q) = 1\)</span> and <span class="math">\(Q*Q' = I\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionToRotation:T:__TCA.MatrixAdapter:T.row_stride.col_stride:CR">
void <tt class="descname">QuaternionToRotation&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], const MatrixAdapter&lt;T, row_stride, col_stride&gt;&amp; <em>R</em><big>)</big><a class="headerlink" href="#QuaternionToRotation:T:__TCA.MatrixAdapter:T.row_stride.col_stride:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="QuaternionToRotation:T:__TCA.TA">
void <tt class="descname">QuaternionToRotation&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], T <em>R</em>[3 * 3]<big>)</big><a class="headerlink" href="#QuaternionToRotation:T:__TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above except that the rotation matrix is normalized by the
Frobenius norm, so that <span class="math">\(R R' = I\)</span> (and <span class="math">\(\det(R) = 1\)</span>).</p>
</dd></dl>

<dl class="function">
<dt id="UnitQuaternionRotatePoint:T:__TCA.TCA.TA">
void <tt class="descname">UnitQuaternionRotatePoint&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], const T <em>pt</em>[3], T <em>result</em>[3]<big>)</big><a class="headerlink" href="#UnitQuaternionRotatePoint:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates a point pt by a quaternion q:</p>
<div class="math">
\[\text{result} = R(q)  \text{pt}\]</div>
<p>Assumes the quaternion is unit norm. If you pass in a quaternion
with <span class="math">\(|q|^2 = 2\)</span> then you WILL NOT get back 2 times the
result you get for a unit quaternion.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionRotatePoint:T:__TCA.TCA.TA">
void <tt class="descname">QuaternionRotatePoint&lt;T&gt;</tt><big>(</big>const T <em>q</em>[4], const T <em>pt</em>[3], T <em>result</em>[3]<big>)</big><a class="headerlink" href="#QuaternionRotatePoint:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><p>With this function you do not need to assume that q has unit norm.
It does assume that the norm is non-zero.</p>
</dd></dl>

<dl class="function">
<dt id="QuaternionProduct:T:__TCA.TCA.TA">
void <tt class="descname">QuaternionProduct&lt;T&gt;</tt><big>(</big>const T <em>z</em>[4], const T <em>w</em>[4], T <em>zw</em>[4]<big>)</big><a class="headerlink" href="#QuaternionProduct:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[zw = z * w\]</div>
<p>where <span class="math">\(*\)</span> is the Quaternion product between 4-vectors.</p>
</dd></dl>

<dl class="function">
<dt id="CrossProduct:T:__TCA.TCA.TA">
void <tt class="descname">CrossProduct&lt;T&gt;</tt><big>(</big>const T <em>x</em>[3], const T <em>y</em>[3], T <em>x_cross_y</em>[3]<big>)</big><a class="headerlink" href="#CrossProduct:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\text{x_cross_y} = x \times y\]</div>
</dd></dl>

<dl class="function">
<dt id="AngleAxisRotatePoint:T:__TCA.TCA.TA">
void <tt class="descname">AngleAxisRotatePoint&lt;T&gt;</tt><big>(</big>const T <em>angle_axis</em>[3], const T <em>pt</em>[3], T <em>result</em>[3]<big>)</big><a class="headerlink" href="#AngleAxisRotatePoint:T:__TCA.TCA.TA" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[y = R(\text{angle_axis}) x\]</div>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="solving.html" class="btn btn-neutral float-right" title="Solving"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorial.html" class="btn btn-neutral" title="Tutorial"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014 Google Inc.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.9.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
      MathJax.Hub.Config({
          "HTML-CSS": {
            availableFonts: ["TeX"]
          }
        });
      </script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49769510-1', 'ceres-solver.org');
  ga('send', 'pageview');
</script>


</body>
</html>